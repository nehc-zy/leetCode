# 计算机基本组成

### 存储器

​	存储字长：存储单元的长度

​	存储器：存储体，MDR，MAR

​	MDR：保存从存储体取出或者将要存入的数据，位数体现存储单元长度

​	MAR：保存存储体的地址，位数体现存储单元的地址容量

### 指令

操作码+存储地址，指令和数据都以二进制位存储在存储体当中，不作区分

### 运算过程

ALU直接实现了加法和除法，直接实现乘法和除法代价较高

#### 加法操作过程

​                                           、<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220328095251329.png" alt="image-20220328095251329" style="zoom: 50%;" />   

#### 减法操作过程

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220328095513017.png" alt="image-20220328095513017" style="zoom: 50%;" />

#### 乘法操作过程

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220328095918906.png" alt="image-20220328095918906" style="zoom: 50%;" />

乘法操作原理：

为什么ACC要清零：之后要完成累加操作，所以要清零

ACC放的是被乘数，先将其转移到X中，乘数放在MQ中，两者相乘，ACC放结果高位，MQ放结果低位

#### 除法操作过程

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220328101000923.png" alt="image-20220328101000923" style="zoom:50%;" />

除法操作原理：被除数减除数，最后的余数放在ACC中，商放在MQ当中

<u>为什么这里的MQ不先清零？？？</u>

加减乘除底层的逻辑电路实现这里先不深究



### 控制器

#### 控制器的功能

解释指令：解释指令指的是从取指到执行到保存结果一系列的过程

保证指令的按序执行

完成指令的过程：

1.取指令，控制器执行，体现在PC

2.分析指令，控制器执行

3.执行指令，控制器执行



### 衡量计算机硬件性能

#### 指令周期：

计算机取出并执行一条指令的时间。

#### CPU周期（亦称机器周期）：

一条指令执行过程被划分为若干阶段，例如，取指令、[存储器](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%99%A8/1583185)读、存储器写等，这每一项工作称为一个基本操作（注意：每一个基本操作都是由若干CPU最基本的动作组成）。完成一个**基本操作**所需要的时间称为机器周期。通常用内存中读取一个字的最短时间来规定CPU周期。

#### 时钟周期：

又称震荡周期，是处理操作的最基本单位。为什么需要时钟周期，主要是用于同步，比如CPU从内存中读8位的数据，放到寄存器中，8位同时读，肯定不可能同时到达，就会出现错误，如果这个错误的数据拿去运算，错误会放大，所以需要一个时钟，让读取这个动作发生在电压的上升沿，其余时间将各个电平保持，也就是说，确保8位数据在这个时间周期内能够读到寄存器上，除此之外，还有加法器的例子：

![image-20220330094728397](C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220330094728397.png)

两个输入，然你输出相加结果，这个过程需要时间，如果没有时钟，可能只有几位变化，有些加法器可能需要多个时钟周期才能确保最后结果正确

即一个指令周期，包含多个 CPU 周期，而一个 CPU 周期包含多个时钟周期。

#### 以运算器为中心的冯诺依曼结构

输入输出的信息到达存储器需要算数逻辑单元ALU参与

#### 以存储器为中心的冯诺依曼结构

输入输出的信息到达存储器不需要算数逻辑单元ALU参与

所谓的指令集，就是软硬件的接口

#### 汇编语言和高级语言

汇编语言指令集不同，则原先汇编，转成机器码就不能实现了，需要重新设计一套符号和机器码的对应形式，不同指令集，机器码就不一样，原先的对应关系就失效了，需要重新设计

高级语言会被编译器编译成不同Cpu指令集对应的汇编语言，所以他不用考虑底层的硬件，即相当于根据不同平台给你转成不同的汇编

![image-20220329103244957](C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220329103244957.png)

同一个操作，实现的指令步骤或者对应的机器码是不一样的，原先的汇编语言翻译后面临机器码对不上的问题，如果指令步骤完全一致，知识机器码的差别，或许可以修改汇编器，将其指向另一种体系结构对应的机器码，但是也有可能指令步骤也完全不一样，这样就没有办法转



## 总线

各个部件**共享**的传输介质

串行：单根数据线，一个位一个位进行传输

并行：多根数据线，多个位同时进行传输，长距离的情况下线之间会发生干扰，导致出错

### 总线结构

#### 单总线结构

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220329105409174.png" alt="image-20220329105409174" style="zoom: 67%;" />

每次只能一对设备用，造成计算机瓶颈，如果设备数量较多，总线长度过长

#### 面向CPU的双总线结构

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220329105703630.png" alt="image-20220329105703630" style="zoom:67%;" />

相当于CPU单独连接主存，问题在于一旦主存和I/O设备之间存在数据交换，都要通过CPU，CPU原先的操作都会被打断

#### 面向存储器的双总线结构

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220329144242729.png" alt="image-20220329144242729" style="zoom:67%;" />

主存可以直接和I/O接口进行连接，但是按照现在的技术，主存在存储总线以及主存在系统总线上的数据传输不能同时进行



### 总线的分类

#### 片内总线：芯片内部之间的总线

#### 系统总线（可以理解成片间总线）：计算机各部件之间的信息传输线

1.数据总线：机器字长为64位，存储字长为8位，一般来说，数据总线宽度小于等于这两者，这样传一个64位的数据就要传8次，数据总线是双向的

2.地址总线：与存储器中的MDR位数长度一样，是单向的

3.控制总线：类似外设端口发送给CPU的中断信号也是通过控制总线进行传输的

#### 通信总线（从计算机内部扩展到计算机外部）

计算机系统之间或者计算机系统与其他系统之间的通信

传输方式：串行通信总线，并行通信总线

### 

### 总线性能及性能指标

在计算机中表现就是一根根并列的印刷电路板，上面留出了很多接口，很多插板可以插上去

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220329145355340.png" alt="image-20220329145355340" style="zoom:67%;" />



#### 总线特性：

机械特性：尺寸、形状、管脚数及排列顺序

电气特定：数据传输方向和有效的电平范围

功能特性：每根传输线的功能

时间特性：时序电路信号的时序 不懂



#### 总线的性能指标

 总线宽度：数据线的根数

标准传输率：每秒传输的最大字节数（MBps）

时钟同步/异步：同步、不同步

总线复用：地址线和数据线复用，8086就是这样的结构，20位地址可以用来传输地址，然后16位用来传输数据

信号线数：地址线、数据线和控制线的总和

总线控制方式：突发、自动、仲裁、逻辑、计数

其他指标：负载能力，比如总线上可以挂载多少个I/O设备



#### 总线标准

不同厂商生产的配件要能接到同一条总线上，所以要有标准

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220329152136260.png" alt="image-20220329152136260" style="zoom:67%;" />

总线时钟的8Mhz，每秒传输8M次，数据线16位，一次传输两个字节，所以每秒传输字节数 8M * 2，就是16MBps

涉及到频率，以及带宽，之间的进制转换是1000

总线频率体现的是数据传输速率，即总线频率 * 数据线 / 8就是每秒能传输多少数据（总线的同步通过外频控制？）

而时钟频率是用来同步的，两者不是一个概念

### 总线判优控制

主设备：对总线有控制权

从设备：响应从主设备发来的总线命令

总线判优：集中式（链式查询、计数器定时查询、独立请求方式），分布式  

#### 链式查询

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220331160717654.png" alt="image-20220331160717654" style="zoom:67%;" />



BG是一个一个地向下进行查询，碰到第一个提出请求的设备，是事先决定好的

优点：结构简单

缺点：在于如果一个出问题了，后面所有的都不能得到总线了，对电路故障特别敏感

用在微型计算机或者嵌入式系统

资料：“当有设备想用总线时，会往BR发送信号，总线控制器收到信号后会发送BG信号。如果有两个设备同时请求，那么次序靠前的会优先收到BG信号，并对其进行拦截。同时它还往BS发送信号，**当总线控制器收到BS信号后，就不再理会是否有设备请求使用总线了**。直到该设备用完总线后，撤销BS信号。”

#### 计数器定时查询



<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220331164806859.png" alt="image-20220331164806859" style="zoom:67%;" />

工作原理：总线控制部件中存在计数器，计数器的值通过设备地址这条线输出，去查询相应的I/O接口，如果不是，计数器的值加1，查询下一个，可以控制计数器的值，从而改变I/O设备的优先级，与链式查询相比，区别在于少了BG线，多了设备地址线。

设备地址线：位数由设备数决定，如果有n个设备，地址位数至少需要logn向上取整

#### 独立请求方式

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220331170046650.png" alt="image-20220331170046650" style="zoom:67%;" />

要求的线数较多，如果有n个设备，需要2*n条线

<u>为什么独立请求方式不用bs线呢？是因为总线控制部件里面有优先级，所以就算一个I/O接口获得了总线，只要一个优先级比它高的I/O接口发起请求就能立马中断？</u>



### 总线通信控制

#### 总线传输周期（一个完整的传输过程）：

申请分配阶段：主模块申请，总线仲裁决定

寻址阶段：主模块向从模块给出地址和命令

传数阶段：主模块和从模块交换数据

结束阶段：主模块撤销有关信息

#### 总线通信的四种方式

##### 同步通信：

定宽定距的时钟来控制整体的同步

##### 同步式数据输入

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220401145959549.png" alt="image-20220401145959549" style="zoom:67%;" />

第一个时钟周期，给出地址信号，第二个时钟周期，给出读控制信号，第三个时钟周期，I/O设备给出数据，第4个周期，数据信号和读控制信号消失，第四个周期结束，地址信号消失。

这里一个时钟周期可能发生多件事，比如读命令发出后到T3周期前，完成了读命令的传输，存储器将数据放到数据总线上，比如给出地址信号，就是地址信号从CPU到I/O设备（或者还包括存储器用这个地址去找的过程），给出数据信号，就是数据信号从I/O设备到CPU，为什么要用时钟，比如地址信号给出两个周期后I/O才给数据，这是为了地址的数据在这个时间内能够到达，这样给的数据才是对的，同理为什么要一个时钟周期后数据信号才能消失，这是为了确保数据能完整地到达CPU，如果没有时钟，很多时候不能确定上一步的数据是否正确，下一步的数据有时候要依靠上一步的数据，或者数据传输过程中可能有问题。

##### 同步式数据输出

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220401153439624.png" alt="image-20220401153439624" style="zoom:67%;" />

可以看出传输数据主要花差不多半个周期，写命令需要两个周期，则可以将同步输入时的图理解为T2的前半个周期读命令传输到存储器，后半个周期准备数据到数据总线上

##### 异步通信

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220401153948351.png" alt="image-20220401153948351" style="zoom:67%;" />

时钟是为了确保在这个时间内，相应的信号能到达目的地，比如发邮件咨询，一周后查看，因为确认一周内一定会回复，异步就相当于发邮件，邮件客户端提示你对方有回件，再进行查看



##### 半同步通信

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220401160133910.png" alt="image-20220401160133910" style="zoom:67%;" />

在第三个周期上升沿将要到来时，应该完成读命令到达内存，内存将相应的数据放到数据总线上，但是因为内存的速度差异，可能还没准备好，会设置一个wait信号为低电平，在第三个时钟周期的上升沿，CPU检测这个信号，如果为低电平就多给一个Tw的准备时间，直到检测到高电平，就可以去数据总线总线上读数据

##### 分离式通信

为了充分挖掘系统每个瞬间的潜力

一个总线传输周期

子周期1：主模块申请占用总线，使用完后立即放弃总线的使用权

子周期2：从模块申请占用总线，将各种信息送至总线上

与之前相比，之前主模块一直占用总线，主模块和从模块之间进行数据传输，分离式通信子周期2从模块将变成主模块

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220401161329975.png" alt="image-20220401161329975" style="zoom:67%;" />

从模块变成主模块后传输数据也是按照同步，即给地址，给数据，给写命令等

<u>为什么地址总线的信号要多维持一个周期？</u>

### 存储器

#### 按照存取方式分类

（1）存取时间与物理地址无关（随机访问，即随意一个地址找到的时间都一样，被称为随机存储器）

随机存储器（这个“随机存储器”与上面的随机存储器不是一个概念，历史遗留问题）：在程序的执行过程中可读可写

只读存储器：在程序的执行过程中只读



（2）存取时间与物理地址有关（串行访问）

顺序存取存储器：磁带

直接存取存储器：磁盘（比如机械硬盘）



#### 按照在计算机中的作用分类

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220403101534950.png" alt="image-20220403101534950" style="zoom:67%;" />

Flash Memory一般指高性能的U盘和固态硬盘ssd



#### 存储器的层次结构

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220403102419243.png" alt="image-20220403102419243" style="zoom:67%;" />

缓存一部分在CPU内部，一部分在CPU外部，是因为要提升速度，但是技术限制已经不能在CPU中大量增加缓存的数量，就把它放在了外面

#### 层次结构

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220403103116372.png" alt="image-20220403103116372" style="zoom:67%;" />

要把存储器组合成整体来看，将主存缓存看做一个整体，是因为程序有时候过大，超过了主存的上限，将其看做一个整体可以解决容量不足的问题，对应主存-辅存层次，将缓存和主存看做一个整体，是为了解决主存和CPU之间速度不匹配的问题，被称为缓存-主存层次。

在找缓存中的内容时，使用的是主存的地址（这里应该是实际地址，实地址，物理地址），映射到缓存中的位置

在找主存中的内容时，使用虚地址，是从0开始的逻辑地址，找的时候将其转化为实际地址



### 主存储器

#### 主存的基本组成

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220403105230998.png" alt="image-20220403105230998" style="zoom:67%;" />

#### 主存和CPU的联系

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220403105411952.png" alt="image-20220403105411952" style="zoom:67%;" />

MDR和MAR逻辑上属于主存，物理上属于CPU

#### 主存中存储单元地址的分配

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220403110610806.png" alt="image-20220403110610806" style="zoom:67%;" />

存放一个机器字的存储单元，通常称为字存储单元，相应的地址称为字地址，存放一个字节的单元，称为字节存储单元，相应的地址称为字节地址

#### 主存的技术指标

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220403110928911.png" alt="image-20220403110928911" style="zoom:67%;" />

存取周期的开始节点是将数据存入存储器（给出地址信号开始）的时间+下一次能够再执行这个存操作的时间，存取周期的倒数乘每次读取的位数可以算出带宽

存取时间就单纯是指数据存入存储器的时间（给出地址信号开始，数据到达预定的位置结束），所以存储周期大于存储时间

总线周期中包含了存取时间，一次总线周期要么存，要么读，所以肯定要这个存取周期结束了，下一个总线周期才能开始，可以理解为数据信号消失后还要一段时间才能结束，就是为了等存取周期结束



### 半导体存储芯片简介

#### 半导体存储芯片的基本结构

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406094018508.png" alt="image-20220406094018508" style="zoom:67%;" />

片选线：该芯片是否被选中，比如内存条上由多个芯片组成，cs低电平表示被选中

读/写控制线：分一条线控制或者两条线控制



#### 存储器片选线的作用

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406094946270.png" alt="image-20220406094946270" style="zoom: 67%;" />

#### 半导体存储芯片的译码驱动方式

##### 线选法

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406100240581.png" alt="image-20220406100240581" style="zoom:67%;" />

缺点在于容量一大， 需要在内存中高度集成，比较困难





##### 重合法

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406103229498.png" alt="image-20220406103229498" style="zoom:67%;" />

将存储单元从线选法的一维数组转变为二维数组，可以减少集成度

### 随机存取存储器（RAM）

#### 静态RAM

运用触发器保存0和1，电路结构，读，写操作都是逻辑电路，不做关注了

#### 动态RAM

利用电容保存0和1，电容会漏电

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406105241267.png" alt="image-20220406105241267" style="zoom:67%;" />

读写也涉及数字逻辑电路，不做关注

#### 动态RAM刷新

##### 集中刷新：每一次刷新一行

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406193335290.png" alt="image-20220406193335290" style="zoom:67%;" />

在刷新时间间隔内，前3872个周期可以正常读取，后128周期内进行刷新，无论是CPU还是I/O进行数据交换，为死区，只能等待

##### 分散刷新

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406195218627.png" alt="image-20220406195218627" style="zoom:67%;" />

Tm就是0.5us，原先的存取周期，TR是对某一行的刷新时间，两个合起来变成新的存取周期，就是1us，相对于集中刷新的2ms时间内，128行刷新了15.6次，就有些频繁

##### 异步刷新（分步刷新与集中刷新相结合）

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406200150941.png" alt="image-20220406200150941" style="zoom:67%;" />

集中刷新是每一次存取周期后就刷新一行，异步刷新是多个存取周期后刷新一行，依然以2ms为界，要在2ms内完成128行的刷新，分成128份，每份15.6us，15.6us的某一个存取周期中进行刷新，这样2ms就能刷新128次

死区为15.6us中的某一个0.5us的周期，但是控制得好可以没有死区

#### 动态RAM和静态RAM的比价

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406203656672.png" alt="image-20220406203656672" style="zoom:67%;" />

内存用的是DRAM，缓存用的是SRAM 

### 只读存储器（ROM）

#### 只读存储器的发展历程

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406205420655.png" alt="image-20220406205420655" style="zoom:67%;" />

#### 掩模ROM（MROM）

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406205853197.png" alt="image-20220406205853197" style="zoom:67%;" />

这种存储器就是厂家事先写好的

#### PROM（一次性编程）

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406205945331.png" alt="image-20220406205945331" style="zoom:67%;" />

厂家未写好，可以自己写，但只能写依次，0的地方用大电流烧断，破坏性编程

#### EPROM（多次性编程）

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406210309313.png" alt="image-20220406210309313" style="zoom:67%;" />

紫外线擦写

#### EEPROM（多次性编程）

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406210457418.png" alt="image-20220406210457418" style="zoom:67%;" />

电可擦写

### 存储器与CPU的连接

#### 存储器容量的扩展

##### 位扩展：比如1位的存储单元拼成8位的的存储单元

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220407100845424.png" alt="image-20220407100845424" style="zoom:67%;" />

存储器位扩展的时候是否需要将地址线和数据线按序连接？

地址线不需要，接收到的地址都是这个地址，数据线需要，两个2114芯片按照不同顺序读出来的数据分为高位低位，会产生大端小端的差别

##### 字扩展

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220407102901121.png" alt="image-20220407102901121" style="zoom:67%;" />

1K需要10根地址线，包括A0-A9，现在将两个1K的芯片拼在一起，就会多出一条A10，总共是11条地址信啊，A10为0，选择第一个芯片，A10为1，选择第二个芯片，A10这根地址线多出来做片选信号

每个芯片的8位数据线连接到D0-D7的数据输出上，两个芯片不能同时工作，因为一共只有8位

##### 字、位扩展

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220407144051119.png" alt="image-20220407144051119" style="zoom:67%;" />

多出来的两条地址线做通过译码器做片选，同时连到两个芯片上，这样就扩展成8位

怎么确定地址线和数据线的位数，看最后需要的寻址空间和存储字长的位数（存储字长即为MDR的位数，存储单元的位数，这里MAR寻址时不考虑字长，比如存储字长为4,001到002地址之间就隔了4个bit，如果存储字长为8，就隔了8位）

### 存储器和CPU的连接

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220407152948123.png" alt="image-20220407152948123" style="zoom:67%;" />

写出需要的地址范围，可以看出系统系统空间需要2K的寻址空间，即11根地址线，用户空间需要1K的寻址空间，即9根地址线

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220407152728740.png" alt="image-20220407152728740" style="zoom:67%;" />

那么A0-A10连接2Kx8位的芯片，A0-A9连接两片1Kx4的芯片，138译码器有三个输入端，三个控制端，因此三个输入端接A11-A13，当输出端为4时，选择2Kx8的地址，当输出端为5时，选择两片1Kx4的芯片，观察前面的地址范围可以只知道A15一直是0，A14一直是1，而138译码器的控制端需要G1一直是高电平，G2A和G2B一直是低电平，所以A14连接G1，本来应该A15同时连接G2A和G2B就行，但是还多出来一个MREQ信号，这个信号为低电平表示存储器被选中，否则就是选中的I/O，将它接在G2B上，如果MREQ是高电平，那么译码器不工作，Y0-Y7都是高电平，芯片没有片选，就不会寻找到存储器的地址。

还有一点需要注意，当译码器输出信号为5时，选择两片1Kx4的芯片，看地址这个时候的A10位为0，所以两个同时成立的时候才能表示，选中了两片1Kx4

为什么不直接不管A10位，只用Y5的输出的片选信号呢？

因为逻辑上来说虽然这时候的片选信号选中了这个芯片，但是如果A10置1，这个逻辑上的地址不在这个芯片内，但是却找到这个芯片里去了

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220408105743235.png" alt="image-20220408105743235" style="zoom:67%;" />

如果用8kx8位的芯片要怎么做

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220408105908929.png" alt="image-20220408105908929" style="zoom:67%;" />

不确定，最后三位做片选，当片选信号为0且A12位0选4K芯片，当片选信号为0且A12位为0选8K芯片，当盘旋信号为1且A12位为1选8K芯片？

### 存储器的校验

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220408152157889.png" alt="image-20220408152157889" style="zoom:67%;" />

编码的检测能力和纠错能力与合法代码之间的差异有关，这被定义为代码之间的最小差异

如果最小差异为奇数，那么能检测到的错误就是1-n/2(舍去0.5）,再增大改变的数目又能归类到1-n/2 ，同时能纠正的也就是1-n/2，所以检错能力为n/2，纠错能力为n/2，总共加起来为n-1

如果最小差异数为偶数，那么能检测到的错误就是1-n/2(不用舍去0.5),同上，但是n/2的时候不知道是这半部分出问题，还是余下的半部分出问题，所以纠错能力只有n/2 - 1，总共加起来为n-1

所以最小差异数为n时，检错能力和纠错能力加起来总是为n-1

#### 编码的最小距离

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220411091851306.png" alt="image-20220411091851306" style="zoom:67%;" />

#### 汉明码的组成

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220411192827800.png" alt="image-20220411192827800" style="zoom:67%;" />

奇偶校验：奇校验，加上校验位，使1的个数为奇数个；偶校验，叫上校验位，使1的个数为偶数个

怎么校验，用异或实现，比如奇校验，各位进行异或，最终预期的结果应该是1；偶校验，各位进行异或，最终预期的结果应该是0

上图进行偶校验，首先对各位的数字进行分组，分成了三组，然后对各组进行校验，可以发现，校验结果正好显示出错的位置，这就是通过分组得到的，即我们应该选择怎么样的分组，来达到这样的效果

分组原则：将位置的二进制代码写出来，可以发现，从最右侧开始，第一组的第一位都是1，第二组的第二位都是1，第三组的第三位都是1，同理，第四组的第四位都是1，第五组的第五位都是1，也就是说给一个位置，我们通过它是否在每一组，写出每一位是1还是0，就可以得到这个位置

那么这样分组造成的结果就是，比如第一组出错，那么该位置就是在第一组，从右往左第一位置1，刚好契合校验出来的1放在最右端，第二组出错，那么该位置的就是在第二组，该位置的二进制代码从右往做第二位就是1，刚好契合校验出来的1放在从右往左第2个位置，所以校验的结果按照组别从右开始从小到大排列，就是该位置的二进制代码



#### 检测位三要素

##### 需添加几位检测位？

原先有n为，加上检测位k位，就是分成k组，那么可能的表示状态为2的k次，要能够覆盖n+k位置出现的错误，还包括一个没有错的情况，即n+k+1

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220411195447606.png" alt="image-20220411195447606" style="zoom:67%;" />

##### 检测位的位置

约定俗成为2的i次，第i组就是2的i-1次

##### 检测位的取值

一般为偶校验

#### 实例

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220411202727624.png" alt="image-20220411202727624" style="zoom:67%;" />

异或为1，为奇数个1，所以校验位为1；异或为0，为偶数个1，所以校验位为0，刚好对应异或结果，所以可以用异或结果来求校验位的值

汉明码的纠错

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220411203117839.png" alt="image-20220411203117839" style="zoom:67%;" />

偶校验不出错时异或都为0

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220411205306343.png" alt="image-20220411205306343" style="zoom:67%;" />

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220411210436480.png" alt="image-20220411210436480" style="zoom:67%;" />

奇校验的汉明码纠错时只要将校验码取反就能找到位置

##### 汉明距离

<u>先不关注了</u>



### 提高访存速度的措施

#### 单体多字系统

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220412093107875.png" alt="image-20220412093107875" style="zoom:67%;" />

CPU机器字长16位，存储字长64位，CPU一次读取64位数据放入4个16位组成的数据寄存器中，再从中选出自己需要的16位指令或者数据放到单机器字长寄存器中，这样下一条指令可以直接在数据寄存器中取

问题：

1.取指令时，有可能不是相邻的指令，比如第一个指令是跳转指令，这样只有一条指令时有效的

2.写入时，先放入单字长寄存器，再放入数据寄存器，一次只写入16位，另外48位将存储器相应位置的值修改，这种修改是错误的

#### 多体并行系统（高位交叉）

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220412094033517.png" alt="image-20220412094033517" style="zoom:67%;" />

虽然存在并行的基础，但是大部分指令都是相邻的，所以CPU读指令会造成一个存储体过于繁忙，其他存储体空闲（就和一个存储体差不多），所以适合容量进行扩展，但是不适合提高存取速度

#### 多体并行系统（低位交叉）

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220412095119475.png" alt="image-20220412095119475" style="zoom:67%;" />

这样编址连续的指令会依次在M0，M1，M2，M3中出现，这里采用的是分离式通信，CPU申请总线的使用权，发送地址，发送控制信号，然后放弃总线的使用权，存储体去读，CPU还可以再申请总线，发送地址，发送控制信号给其他的存储体，然后放弃总线的使用权，当存储体准备好数据之后申请总线使用权，将数据传给CPU

#### 低位交叉的特点

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220414153919439.png" alt="image-20220414153919439" style="zoom:67%;" />

这里的总线传输周期就是存取时间，在一个存取周期内，CPU在存取时间完成依次读写操作，但是再一次读取需要存取周期结束，在这个时间内可以申请对其他存储体的访问，形成流水线

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220414153943615.png" alt="image-20220414153943615" style="zoom:67%;" />

为了实现流水线，比如存取周期为T，存取时间为t，那么我们就可以低位交叉选择 T/t个存储体

如果是k个存储单元，就是T+（k-1）t

### 高速缓冲存储器

Cache要起到作用，就要保证要取的数据大部分都在Cache中，需要程序访问的局部性原理



1.时间局部性：当前正在使用的指令或数据在不久的将来还会再使用

2.空间局部性：当前正在使用的指令或数据在不久的将来相邻的指令或数据还会再使用

所以Cache中主要存正在使用的指令和数据以及响相邻的指令或数据



#### Cache的工作原理

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220414152220852.png" alt="image-20220414152220852" style="zoom:67%;" />

实际上没有缓存地址，只有主存的地址，如果一个主存块被写到Cache当中，就在Cache之前的标记写入主存块号，CPU读取时把给出地址的主存块号和标记进行比较

#### 命中与未命中

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220414152805916.png" alt="image-20220414152805916" style="zoom:67%;" />

#### Cache的命中率

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220414153151400.png" alt="image-20220414153151400" style="zoom:67%;" />

有n1次访问到了指令，有n2次没有访问到，命中率就是n1/(n1+n2)

命中率与Cache的容量有关，比如Cache的容量越大，和主存相等，除了第一次不能命中，后面每次都能命中；块长过小，没几步指令就要新的块，就可能没命中，没有充分利用程序的局部性原理；块过大，Cache的容量是有限的，块数比较少，一个块中可能只有几条指令要用到，就要加载新的块

### 主存系统的效率

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416142151667.png" alt="image-20220416142151667" style="zoom:67%;" />

平均访问时间是指，访问n次，命中Cache的次数n*h，没命中Cache的次数n*（1-h），所以平均依次的访问时间（n*h*Tc + n*（1-h）*Tm） / n,简化就是图中平均访问时间的公式，主存的访问时间包括去寻找访问Cache未命中的时间和未命中后访问主存的时间

注意，可以看出CPU访问Cache和访问主存是并行的，在访问Cache的同时也在访问主存，如果Cache先找到，立即返回数据，如果Cache没有，此时主存也一直在找，主存返回数据。如果访问Cache和访问主存是串行的，访问主存的时间就要加上Tc

<u>没命中访问主存不是还要把数据写到Cache中么？这个时间不用加上么</u>（没命中时去主存中找数据，同时也会将数据装载入Cache的相应位置）

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416195335425.png" alt="image-20220416195335425" style="zoom:67%;" />

没有命中Cache也要先访问，拿出数据进行判断，所以也要花Tc时间

同时访问Cache和主存，访问没命中时，主存访问已经进行一部分了，继续就行，给出数据的同时还会把相应的块装载入Cache中

#### Cache的基本结构

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416143735970.png" alt="image-20220416143735970" style="zoom:67%;" />

映射：确定要查找的主存在Cache中的位置

变换：将主存的块号转变为Cache中的块号

直接通路负责主存和Cache中的数据交换，替换算法就要用到

#### Cache的读操作

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416195806727.png" alt="image-20220416195806727" style="zoom:67%;" />

没命中时去主存取与Cache替换同时进行

Cache替换是否满是指该块放的地方是否满，而不是Cache整体是否满

一般来说访问Cache和访问主存是同时进行的

#### Cache的写操作

面临不一致问题，Cache和主存的一致性

##### 写直达法

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416203235479.png" alt="image-20220416203235479" style="zoom:67%;" />

优点是Cache和主存一直保持一致，可能造成CPU对同一个内存单元反复地写，如执行求和，每一次赋到一个内存地址，就要重新写，实际上只要取最后一次再写就行

##### 写回法

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416203420579.png" alt="image-20220416203420579" style="zoom:67%;" />

无法实时保持一致，比如多处理器每个Cache里都有一个副本



#### Cache的改进

增加Cache的级数

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416203635605.png" alt="image-20220416203635605" style="zoom:67%;" />

一般CPU内部2片，CPU外部主板上1片，所以至少有3级

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416203728246.png" alt="image-20220416203728246" style="zoom:67%;" />

### 地址映射

#### 直接映射

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416204657707.png" alt="image-20220416204657707" style="zoom:67%;" />

很多存储字组成一个块，很多块组成一个区，组成区的块数量就根据Cache中的来，主存由这样一个一个区组成，给出主存地址，可以得到Cache自块地址，这里一个区的大小是2的c次方，所以Cache字块地址只能是0-2的c次方减1，然后直接映射到Cache的相应位置，主存字块标记说明了是第几个区，和Cache中的标记比较就能知道当前块是否是选中的块

c决定了一个区内是哪个块，t决定了这个块是哪个区的

#### 全相连映射



<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416205538108.png" alt="image-20220416205538108" style="zoom:67%;" />

全相连映射就是块可以放到Cache存储器中的任何一个块中，只要有空位，那么t+c实际上就是字块的数量，也就是m，在给出主存地址时，需要比较Cache存储器中的所有块，看是否标记相同，标记的位数也会变长

直接映射和全相连映射走了两个极端，直接映射的块只能放到一个位置，全相连映射的块可以放到任意位置，组相连映射结合了两者

#### 组相连映射

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416211453828.png" alt="image-20220416211453828" style="zoom:67%;" />

本来是将主存储器中数量为Cache块数量的作为一个区，现在是将Cache中的块分组，位数为r，所以分出来的组为2的c-r次，将主存中2的c-r个块作为一个区，将组地址映射到某个组中，然后组中可以随便映射，比对标记即可

从位数上看，后面的s中的r位决定了组中的第几列，s中的t决定了原来区大小是哪个区，一方面需要确定是在组中的哪个位置，另一方面需要确定原来区大小的是哪个区，所以需要t+r位，实际上在组内的映射是无序的

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416212509527.png" alt="image-20220416212509527" style="zoom:67%;" />

距离CPU近的，要求速度，可以用直接映射，距离CPU远的，对速度要求不高，可以用全相连，中间的可以用组相连，直接映射速度快，只要命中，马上就能找到位置拿数据，但对CPU的利用率不高，全相连对CPU利用率高，但是每个都要比较，速度比较慢



#### 替换算法

主要针对全相连和组相连

##### 先进先出（FIFO）算法

有可能被替换出去的块马上要用到，不符合程序的局部性原理

##### 近期最少使用（LRU）算法

#### 小结

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416214843807.png" alt="image-20220416214843807" style="zoom:67%;" />

### 辅助存储器

不直接与CPU交换数据（硬盘、U盘、光盘等）

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416220416939.png" alt="image-20220416220416939" style="zoom:67%;" />

越往外位密度越低

n是盘面数，k是磁道数，s是每个磁道存放的二进制信息

#### 磁记录原理

物理原理不关注了

##### 写

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416220812106.png" alt="image-20220416220812106" style="zoom:67%;" />

##### 读

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416220734784.png" alt="image-20220416220734784" style="zoom:67%;" />

#### 硬磁盘存储器

##### <img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416221229006.png" alt="image-20220416221229006" style="zoom:67%;" />

固定磁头每个磁道都有个磁头

##### 磁盘控制器

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416221426577.png" alt="image-20220416221426577" style="zoom:67%;" />

##### 盘片

硬质铝合金结构

#### 软磁盘存储器

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416221737109.png" alt="image-20220416221737109" style="zoom:67%;" />

#### 光盘存储器

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416222010992.png" alt="image-20220416222010992" style="zoom:67%;" />

### 输入输出系统

接口：

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417134908116.png" alt="image-20220417134908116" style="zoom:67%;" />

接口的功能：

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417134942472.png" alt="image-20220417134942472" style="zoom:67%;" />

#### 输出输入系统的发展

##### 分散连接

每个I/O设备单独与CPU相连，采用程序查询方式，串行工作（I/O进行数据输入输出的时候CPU必须运行相应程序或者停）

##### 接口模块和DMA阶段

总线连接

CPU和I/O设备并行工作 ，分为中断方式和DMA方式

##### 具有通道结构的阶段

通道可以看做一个微型处理器或者DMA控制器

##### 具有I/O处理机的阶段



#### 输入输出系统的组成

##### I/O软件

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417135848546.png" alt="image-20220417135848546" style="zoom:67%;" />

操作码就可以指出是I/O指令，命令码就是一般指令的操作，设备码是I/O设备的地址

##### I/O硬件

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417135950366.png" alt="image-20220417135950366" style="zoom:67%;" />

两种方式，一种是外部设备通过I/O接口连接总线，总线连接主机；另一种是通道方式，I/O设备连接设备控制器，设备控制器连接子通道，子通道再连接通道

### I/O设备与主机的联系方式

#### I/O设备的编址方式

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417140616855.png" alt="image-20220417140616855" style="zoom:67%;" />

##### 统一编制

将主存的一部分地址看做是I/O设备的地址或者是端口的地址，如果指令的地址码部分落到了I/O指令的地址区，就知道是针对I/O设备，指令也就是一般的取数、存数指令，适用于内存空间比较大的系统

##### 不统一编制

比如主存编制20位，就是1M，I/O设备编制16位，64K，一个地址不能区分是主存的还是I/O设备的，所以有专门的I/O指令

#### 设备选址

用设备选择电路识别是否被选中，将CPU给出的地址和I/O设备自己保存的地址进行比较，相同即被选中

#### 传送方式

串行：一条线，一次传一位

并行：多条线，一次传多位

#### 联络方式

##### 立即响应

接收到输入数据之后立即显示，比如LED灯接收到输入后立刻可以用亮或者不亮表示接收到的数据值

##### 异步工作采用应答信号

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417141707723.png" alt="image-20220417141707723" style="zoom:67%;" />



这里的并行指的是一次传输多位数据，CPU输出时，I/O接口的端口准备好数据，向I/O设备发送ready信号，I/O设备接收到ready信号后，读取数据，读取完毕发送strobe应答信号；CPU输入时，I/O接口端口为空，向I/O设备发送Ready信号，告诉它可以输入，I/O设备输入完成后发送应答信号

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417142722729.png" alt="image-20220417142722729" style="zoom:67%;" />

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417142045762.png" alt="image-20220417142045762" style="zoom:67%;" />

串行只有一根线，通过开头和结束时两个低or高电平告诉对方开始与结束，实现异步

##### 同步工作采用同步时标

定宽定距的时钟来控制某个动作必须在某一时刻开始，在某一时刻完成，如外部设别以2400hz的频率传输数据到接口，CPU也就必须1/2400s到接口取一次数据

#### I/O设备和主机的联系方式

##### 辐射式连接（就是之前的分散连接）

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417143227063.png" alt="image-20220417143227063" style="zoom:67%;" />

##### 总线连接

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417143423985.png" alt="image-20220417143423985" style="zoom:67%;" />

接口有一定的标准，只要外部设备接入时按照一定的接口标准就可以

### I/O设备和主机信息传送的控制方式

#### 程序查询方式

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417144320348.png" alt="image-20220417144320348" style="zoom:67%;" />

CPU不停读I/O状态寄存器的值，所以在I/O外部设备准备数据时，CPU不能空下来，这是这里串行的含义，两者不能同时开展

为什么叫程序查询方式，CPU一旦启动I/O，就停止当前程序的执行（比如一个程序有一条命令读取I/O，就停止当前程序），在当前程序中插入一段程序，来执行上面这个流程图

这不是中断，因为这个流程的程序部分是写在原来的固有程序里面的

#### 程序中断方式

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417145401624.png" alt="image-20220417145401624" style="zoom:67%;" />

CPU在I/O设备准备数据时可以做自己的事，所以是部分并行，但没有完全解放CPU，并且中断时保存上下文也要花费时间和空间，在中断处理程序中，I/O设备依然要等到CPU的指令来进行下一步操作，所以这时候是串行的

##### 程序中断方式流程

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417145923280.png" alt="image-20220417145923280" style="zoom:67%;" />

只有一开始CPU向I/O发读指令的时候两者才是并行的，后面CPU在取数的时候I/O依然要等待



### DMA方式

前面两者都需要CPU的参与，DMA可以将CPU从数据输入输出中解放出来，实现I/O设备和内存之间的直接传输

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417153153702.png" alt="image-20220417153153702" style="zoom:67%;" />

CPU发出启动I/O的指令后开始干自己的事，I/O在DMA控制器的控制下准备数据，当数据准备好时，向DMA控制器发出DMA请求，DMA再向CPU发送总线请求来占用总线，占用一个存取周期，利用这一个存取周期完成外部设备和内存之间的数据交换，这一个存取周期内CPU不可以使用总线和访问内存。有些时候指令时多条放到CPU中的，所以在这个存取周期中也不用这条总线，也不用访问内存，所以也可以并行。存取周期结束后总线的控制权还给CPU。

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417155014163.png" alt="image-20220417155014163" style="zoom:67%;" />

可以看出DMA占用系统总线时CPU就不能用了

关于同步异步，可以理解为有一系列规定要做的动作，但是什么时候做不确定，同步就是给时钟告诉你时钟开始就做一步，异步就是通过信号告诉你可以做，所以程序中断方式中，中断请求一发，中断处理程序执行，之后的程序有很多传输指令，就要考虑同步异步，同理程序查询方式也是如此，一旦状态变更，可以取数了，就可以考虑各个器件之间的同步异步

#### 三种方式的比较

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417160028815.png" alt="image-20220417160028815" style="zoom:67%;" />

DMA方式，CPU还可以继续执行指令，只是不能使用系统总线和访问内存，所以不用像中断程序那样保存上下文

#### 通道方式

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417161011292.png" alt="image-20220417161011292" style="zoom:67%;" />

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417161209926.png" alt="image-20220417161209926" style="zoom:67%;" />

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417161256170.png" alt="image-20220417161256170" style="zoom:67%;" />

通道就是一个简化版的CPU

### I/O设备

#### 概述

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417162739346.png" alt="image-20220417162739346" style="zoom:67%;" />

第三种也包括网卡

#### 输入设备

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417163139149.png" alt="image-20220417163139149" style="zoom:67%;" />

#### 输出设备	

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417163642080.png" alt="image-20220417163642080" style="zoom:67%;" />

#### 其他

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417164851925.png" alt="image-20220417164851925" style="zoom:67%;" />

#### 多媒体技术



### I/O接口

#### 概述

为什么要设置接口

1.外部设备通过总线与主机连接，所以要实现设备的选择

2.实现数据缓冲达到速度匹配

3.实现数据串-并格式转换 主机和I/O接口之间并行传输，I/O接口外部和外部设备之间串行传输，所以要对数据进行拆分和组装

4.实现电平转换，主机和I/O设备的工作电平不一致

5.通过接口传送控制命令

6.反映设备的状态，忙，就绪，中断请求

#### 接口的功能和组成

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418191900114.png" alt="image-20220418191900114" style="zoom:67%;" />

完成触发器D：设备是否准备好，数据是否准备好，D=1，准备工作已经完成，D=0，准备工作尚未完成

工作触发器B：B=1，外部设备忙，B=0，外部设备完成工作，闲

中断请求触发器INTR：中断方式需要用到，接口有中断请求触发器，但又中断请求的情况下也要考虑中断请求的重要性，需要屏蔽触发器

屏蔽触发器MASK：置1，即使有中断也不能向主机发送中断请求



##### 总线连接方式的I/O接口电路

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418190536676.png" alt="image-20220418190536676" style="zoom:67%;" />

设备选择线传设备号和端口号，就是设备和端口地址，单向，传到每个I/O接口中进行比较，相同即选中#

状态线也是单向，传给CPU表达I/O接口的状态

#### I/O接口的基本组成部分

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418191232036.png" alt="image-20220418191232036" style="zoom:67%;" />

#### 接口类型

##### 按照数据传送的方式

并行接口

串行接口

##### 按照功能选择的灵活性分类

可编程接口（可以通过软件的方式设置功能与工作方式）

不可编程接口（不可以通过软件方式，可以通过硬件？硬连？设置功能与工作方式）

##### 按照通用性分类

通用接口

专用接口（只能用于主机对某种外部设备）

##### 按照数据传送的控制方式

程序查询方式不需要接口进行控制（但是有接口）

中断接口（程序中断方式）

DMA方式（DMA方式）



### 程序查询方式

#### 程序查询方式的流程

##### 查询流程

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418192555124.png" alt="image-20220418192555124" style="zoom:67%;" />

检查状态标记：测试指令，准备就绪：跳转指令，交换数据：传送指令或访存指令，多个设备时需要按照优先级进行查询

##### 程序流程

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418193133874.png" alt="image-20220418193133874" style="zoom:67%;" />

计数值是保存在CPU的寄存器或者内存中，每次只传送一个字，这个流程需要程序员自己写程序嵌入到应用程序中去

#### 程序查询方式的接口电路

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418194410176.png" alt="image-20220418194410176" style="zoom:67%;" />

读命令启动，接口比较地址线和自己的地址或者端口地址，只有符合并且有启动命令才会置两个状态标记的值，D置为0，表示还没准备好，B置为1，表示设备忙，同时这个信号发送到设备启动设备，设备准备数据完成并放到DBR后，4信号会重新置D和B的状态位，将D置为1，B置为0，在此之前，CPU一直在查询D的状态，一旦D置为1，就取走数据。



### 程序中断方式

#### 中断的概念

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418195243196.png" alt="image-20220418195243196" style="zoom:67%;" />

#### I/O中断的产生

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418195455457.png" alt="image-20220418195455457" style="zoom:67%;" />

启动打印机的指令在原先的指令里面，CPU和打印机是部分并行工作的

#### 程序中断方式的接口电路

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418195751882.png" alt="image-20220418195751882" style="zoom: 67%;" />

除了程序查询方式中寄存器和状态标志，还需要中断请求触发器和中断屏蔽触发器

##### 中断请求触发器和中断屏蔽触发器

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418200148220.png" alt="image-20220418200148220" style="zoom:67%;" />

MASK输出的是Q非，所以当MASK为0，即不屏蔽中断，和D标志位和在一起才有效

##### 中断排队器

多个设备发送中断，需要排队

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418202208988.png" alt="image-20220418202208988" style="zoom:67%;" />

INTP‘指的是向上输出的那条信号，如果INTR2为1，那么1到2都会输出高电平，2之后的都是低电平，最左边接地为0，取反默认为1，所以中间有中断信号时，一般是1111000的形式，按理来说是最右边的1为真实的中断信号，这里做了与非再非的操作，这样只有真正的中断信号才会输出高电平

##### 中断向量地址形成部件

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418212248635.png" alt="image-20220418212248635" style="zoom:67%;" />

排队器输出只有一个1，设备编码器根据中断向量具体的位置编码出向量地址

### I/O中断处理过程

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418212428551.png" alt="image-20220418212428551" style="zoom:67%;" />

EINT就是汇编中标志寄存器中的IF

#### 图示

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418212455613.png" alt="image-20220418212455613" style="zoom:67%;" />

中断查询信号感觉像是与是时钟有关，CPU在每次指令结束时发送中断查询信号，如果INTR的D口为1，中断查询信号会触发INTR，1就能传送至输出端（自己猜想，可能和寄存器触发刷新类似）

#### 中断服务程序的流程

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418212645725.png" alt="image-20220418212645725" style="zoom:67%;" />

程序断点的保护有些不能用指令进行保存，所以需要硬件来完成，就被称为中断隐指令（因为不是真正的指令）

### 单重中断和多重中断

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418212805291.png" alt="image-20220418212805291" style="zoom:67%;" />

单重中断不论新的中断优先级有多高

#### 单重中单和多重中断的服务程序流程

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418213254021.png" alt="image-20220418213254021" style="zoom:67%;" />

中断隐指令包含断点地址入栈以及一系列其他的操作，这些都是通过硬件完成的，在中断服务程序中才开始执行保存寄存器的指令。多重中断保护现场就是指保护寄存器，为什么保护寄存器要在开中断前，因为上一个程序的寄存器信息还没保存好，保存好之后再开中断。

实际上恢复现场前也要关中断，结束后再开中断、

#### 主程序和服务程序抢占CPU示意图

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418213856016.png" alt="image-20220418213856016" style="zoom:67%;" />

<u>我还是不懂CPU的中断查询信号的具体作用</u>

