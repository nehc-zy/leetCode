# 计算机基本组成

### 存储器

​	存储字长：存储单元的长度

​	存储器：存储体，MDR，MAR

​	MDR：保存从存储体取出或者将要存入的数据，位数体现存储单元长度

​	MAR：保存存储体的地址，位数体现存储单元的地址容量

### 指令

操作码+存储地址，指令和数据都以二进制位存储在存储体当中，不作区分

### 运算过程

ALU直接实现了加法和除法，直接实现乘法和除法代价较高

#### 加法操作过程

​                                           、<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220328095251329.png" alt="image-20220328095251329" style="zoom: 50%;" />   

#### 减法操作过程

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220328095513017.png" alt="image-20220328095513017" style="zoom: 50%;" />

#### 乘法操作过程

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220328095918906.png" alt="image-20220328095918906" style="zoom: 50%;" />

乘法操作原理：

为什么ACC要清零：之后要完成累加操作，所以要清零

ACC放的是被乘数，先将其转移到X中，乘数放在MQ中，两者相乘，ACC放结果高位，MQ放结果低位

#### 除法操作过程

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220328101000923.png" alt="image-20220328101000923" style="zoom:50%;" />

除法操作原理：被除数减除数，最后的余数放在ACC中，商放在MQ当中

<u>为什么这里的MQ不先清零？？？</u>

加减乘除底层的逻辑电路实现这里先不深究



### 控制器

#### 控制器的功能

解释指令：解释指令指的是从取指到执行到保存结果一系列的过程

保证指令的按序执行

完成指令的过程：

1.取指令，控制器执行，体现在PC

2.分析指令，控制器执行

3.执行指令，控制器执行



### 衡量计算机硬件性能

#### 指令周期：

计算机取出并执行一条指令的时间。

#### CPU周期（亦称机器周期）：

一条指令执行过程被划分为若干阶段，例如，取指令、[存储器](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%99%A8/1583185)读、存储器写等，这每一项工作称为一个基本操作（注意：每一个基本操作都是由若干CPU最基本的动作组成）。完成一个**基本操作**所需要的时间称为机器周期。通常用内存中读取一个字的最短时间来规定CPU周期。

#### 时钟周期：

又称震荡周期，是处理操作的最基本单位。为什么需要时钟周期，主要是用于同步，比如CPU从内存中读8位的数据，放到寄存器中，8位同时读，肯定不可能同时到达，就会出现错误，如果这个错误的数据拿去运算，错误会放大，所以需要一个时钟，让读取这个动作发生在电压的上升沿，其余时间将各个电平保持，也就是说，确保8位数据在这个时间周期内能够读到寄存器上，除此之外，还有加法器的例子：

![image-20220330094728397](C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220330094728397.png)

两个输入，然你输出相加结果，这个过程需要时间，如果没有时钟，可能只有几位变化，有些加法器可能需要多个时钟周期才能确保最后结果正确

即一个指令周期，包含多个 CPU 周期，而一个 CPU 周期包含多个时钟周期。

#### 以运算器为中心的冯诺依曼结构

输入输出的信息到达存储器需要算数逻辑单元ALU参与

#### 以存储器为中心的冯诺依曼结构

输入输出的信息到达存储器不需要算数逻辑单元ALU参与

所谓的指令集，就是软硬件的接口

#### 汇编语言和高级语言

汇编语言指令集不同，则原先汇编，转成机器码就不能实现了，需要重新设计一套符号和机器码的对应形式，不同指令集，机器码就不一样，原先的对应关系就失效了，需要重新设计

高级语言会被编译器编译成不同Cpu指令集对应的汇编语言，所以他不用考虑底层的硬件，即相当于根据不同平台给你转成不同的汇编

![image-20220329103244957](C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220329103244957.png)

同一个操作，实现的指令步骤或者对应的机器码是不一样的，原先的汇编语言翻译后面临机器码对不上的问题，如果指令步骤完全一致，知识机器码的差别，或许可以修改汇编器，将其指向另一种体系结构对应的机器码，但是也有可能指令步骤也完全不一样，这样就没有办法转



## 总线

各个部件**共享**的传输介质

串行：单根数据线，一个位一个位进行传输

并行：多根数据线，多个位同时进行传输，长距离的情况下线之间会发生干扰，导致出错

### 总线结构

#### 单总线结构

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220329105409174.png" alt="image-20220329105409174" style="zoom: 67%;" />

每次只能一对设备用，造成计算机瓶颈，如果设备数量较多，总线长度过长

#### 面向CPU的双总线结构

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220329105703630.png" alt="image-20220329105703630" style="zoom:67%;" />

相当于CPU单独连接主存，问题在于一旦主存和I/O设备之间存在数据交换，都要通过CPU，CPU原先的操作都会被打断

#### 面向存储器的双总线结构

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220329144242729.png" alt="image-20220329144242729" style="zoom:67%;" />

主存可以直接和I/O接口进行连接，但是按照现在的技术，主存在存储总线以及主存在系统总线上的数据传输不能同时进行



### 总线的分类

#### 片内总线：芯片内部之间的总线

#### 系统总线（可以理解成片间总线）：计算机各部件之间的信息传输线

1.数据总线：机器字长为64位，存储字长为8位，一般来说，数据总线宽度小于等于这两者，这样传一个64位的数据就要传8次，数据总线是双向的

2.地址总线：与存储器中的MDR位数长度一样，是单向的

3.控制总线：类似外设端口发送给CPU的中断信号也是通过控制总线进行传输的

#### 通信总线（从计算机内部扩展到计算机外部）

计算机系统之间或者计算机系统与其他系统之间的通信

传输方式：串行通信总线，并行通信总线

### 

### 总线性能及性能指标

在计算机中表现就是一根根并列的印刷电路板，上面留出了很多接口，很多插板可以插上去

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220329145355340.png" alt="image-20220329145355340" style="zoom:67%;" />



#### 总线特性：

机械特性：尺寸、形状、管脚数及排列顺序

电气特定：数据传输方向和有效的电平范围

功能特性：每根传输线的功能

时间特性：时序电路信号的时序 不懂



#### 总线的性能指标

 总线宽度：数据线的根数

标准传输率：每秒传输的最大字节数（MBps）

时钟同步/异步：同步、不同步

总线复用：地址线和数据线复用，8086就是这样的结构，20位地址可以用来传输地址，然后16位用来传输数据

信号线数：地址线、数据线和控制线的总和

总线控制方式：突发、自动、仲裁、逻辑、计数

其他指标：负载能力，比如总线上可以挂载多少个I/O设备



#### 总线标准

不同厂商生产的配件要能接到同一条总线上，所以要有标准

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220329152136260.png" alt="image-20220329152136260" style="zoom:67%;" />

总线时钟的8Mhz，每秒传输8M次，数据线16位，一次传输两个字节，所以每秒传输字节数 8M * 2，就是16MBps

涉及到频率，以及带宽，之间的进制转换是1000

总线频率体现的是数据传输速率，即总线频率 * 数据线 / 8就是每秒能传输多少数据（总线的同步通过外频控制？）

而时钟频率是用来同步的，两者不是一个概念

### 总线判优控制

主设备：对总线有控制权

从设备：响应从主设备发来的总线命令

总线判优：集中式（链式查询、计数器定时查询、独立请求方式），分布式  

#### 链式查询

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220331160717654.png" alt="image-20220331160717654" style="zoom:67%;" />



BG是一个一个地向下进行查询，碰到第一个提出请求的设备，是事先决定好的

优点：结构简单

缺点：在于如果一个出问题了，后面所有的都不能得到总线了，对电路故障特别敏感

用在微型计算机或者嵌入式系统

资料：“当有设备想用总线时，会往BR发送信号，总线控制器收到信号后会发送BG信号。如果有两个设备同时请求，那么次序靠前的会优先收到BG信号，并对其进行拦截。同时它还往BS发送信号，**当总线控制器收到BS信号后，就不再理会是否有设备请求使用总线了**。直到该设备用完总线后，撤销BS信号。”

#### 计数器定时查询



<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220331164806859.png" alt="image-20220331164806859" style="zoom:67%;" />

工作原理：总线控制部件中存在计数器，计数器的值通过设备地址这条线输出，去查询相应的I/O接口，如果不是，计数器的值加1，查询下一个，可以控制计数器的值，从而改变I/O设备的优先级，与链式查询相比，区别在于少了BG线，多了设备地址线。

设备地址线：位数由设备数决定，如果有n个设备，地址位数至少需要logn向上取整

#### 独立请求方式

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220331170046650.png" alt="image-20220331170046650" style="zoom:67%;" />

要求的线数较多，如果有n个设备，需要2*n条线

<u>为什么独立请求方式不用bs线呢？是因为总线控制部件里面有优先级，所以就算一个I/O接口获得了总线，只要一个优先级比它高的I/O接口发起请求就能立马中断？</u>



### 总线通信控制

#### 总线传输周期（一个完整的传输过程）：

申请分配阶段：主模块申请，总线仲裁决定

寻址阶段：主模块向从模块给出地址和命令

传数阶段：主模块和从模块交换数据

结束阶段：主模块撤销有关信息

#### 总线通信的四种方式

##### 同步通信：

定宽定距的时钟来控制整体的同步

##### 同步式数据输入

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220401145959549.png" alt="image-20220401145959549" style="zoom:67%;" />

第一个时钟周期，给出地址信号，第二个时钟周期，给出读控制信号，第三个时钟周期，I/O设备给出数据，第4个周期，数据信号和读控制信号消失，第四个周期结束，地址信号消失。

这里一个时钟周期可能发生多件事，比如读命令发出后到T3周期前，完成了读命令的传输，存储器将数据放到数据总线上，比如给出地址信号，就是地址信号从CPU到I/O设备（或者还包括存储器用这个地址去找的过程），给出数据信号，就是数据信号从I/O设备到CPU，为什么要用时钟，比如地址信号给出两个周期后I/O才给数据，这是为了地址的数据在这个时间内能够到达，这样给的数据才是对的，同理为什么要一个时钟周期后数据信号才能消失，这是为了确保数据能完整地到达CPU，如果没有时钟，很多时候不能确定上一步的数据是否正确，下一步的数据有时候要依靠上一步的数据，或者数据传输过程中可能有问题。

##### 同步式数据输出

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220401153439624.png" alt="image-20220401153439624" style="zoom:67%;" />

可以看出传输数据主要花差不多半个周期，写命令需要两个周期，则可以将同步输入时的图理解为T2的前半个周期读命令传输到存储器，后半个周期准备数据到数据总线上

##### 异步通信

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220401153948351.png" alt="image-20220401153948351" style="zoom:67%;" />

时钟是为了确保在这个时间内，相应的信号能到达目的地，比如发邮件咨询，一周后查看，因为确认一周内一定会回复，异步就相当于发邮件，邮件客户端提示你对方有回件，再进行查看



##### 半同步通信

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220401160133910.png" alt="image-20220401160133910" style="zoom:67%;" />

在第三个周期上升沿将要到来时，应该完成读命令到达内存，内存将相应的数据放到数据总线上，但是因为内存的速度差异，可能还没准备好，会设置一个wait信号为低电平，在第三个时钟周期的上升沿，CPU检测这个信号，如果为低电平就多给一个Tw的准备时间，直到检测到高电平，就可以去数据总线总线上读数据

##### 分离式通信

为了充分挖掘系统每个瞬间的潜力

一个总线传输周期

子周期1：主模块申请占用总线，使用完后立即放弃总线的使用权

子周期2：从模块申请占用总线，将各种信息送至总线上

与之前相比，之前主模块一直占用总线，主模块和从模块之间进行数据传输，分离式通信子周期2从模块将变成主模块

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220401161329975.png" alt="image-20220401161329975" style="zoom:67%;" />

从模块变成主模块后传输数据也是按照同步，即给地址，给数据，给写命令等

<u>为什么地址总线的信号要多维持一个周期？</u>

### 存储器

#### 按照存取方式分类

（1）存取时间与物理地址无关（随机访问，即随意一个地址找到的时间都一样，被称为随机存储器）

随机存储器（这个“随机存储器”与上面的随机存储器不是一个概念，历史遗留问题）：在程序的执行过程中可读可写

只读存储器：在程序的执行过程中只读



（2）存取时间与物理地址有关（串行访问）

顺序存取存储器：磁带

直接存取存储器：磁盘（比如机械硬盘）



#### 按照在计算机中的作用分类

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220403101534950.png" alt="image-20220403101534950" style="zoom:67%;" />

Flash Memory一般指高性能的U盘和固态硬盘ssd



#### 存储器的层次结构

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220403102419243.png" alt="image-20220403102419243" style="zoom:67%;" />

缓存一部分在CPU内部，一部分在CPU外部，是因为要提升速度，但是技术限制已经不能在CPU中大量增加缓存的数量，就把它放在了外面

#### 层次结构

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220403103116372.png" alt="image-20220403103116372" style="zoom:67%;" />

要把存储器组合成整体来看，将主存缓存看做一个整体，是因为程序有时候过大，超过了主存的上限，将其看做一个整体可以解决容量不足的问题，对应主存-辅存层次，将缓存和主存看做一个整体，是为了解决主存和CPU之间速度不匹配的问题，被称为缓存-主存层次。

在找缓存中的内容时，使用的是主存的地址（这里应该是实际地址，实地址，物理地址），映射到缓存中的位置

在找主存中的内容时，使用虚地址，是从0开始的逻辑地址，找的时候将其转化为实际地址



### 主存储器

#### 主存的基本组成

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220403105230998.png" alt="image-20220403105230998" style="zoom:67%;" />

#### 主存和CPU的联系

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220403105411952.png" alt="image-20220403105411952" style="zoom:67%;" />

MDR和MAR逻辑上属于主存，物理上属于CPU

#### 主存中存储单元地址的分配

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220403110610806.png" alt="image-20220403110610806" style="zoom:67%;" />

存放一个机器字的存储单元，通常称为字存储单元，相应的地址称为字地址，存放一个字节的单元，称为字节存储单元，相应的地址称为字节地址

#### 主存的技术指标

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220403110928911.png" alt="image-20220403110928911" style="zoom:67%;" />

存取周期的开始节点是将数据存入存储器（给出地址信号开始）的时间+下一次能够再执行这个存操作的时间，存取周期的倒数乘每次读取的位数可以算出带宽

存取时间就单纯是指数据存入存储器的时间（给出地址信号开始，数据到达预定的位置结束），所以存储周期大于存储时间

总线周期中包含了存取时间，一次总线周期要么存，要么读，所以肯定要这个存取周期结束了，下一个总线周期才能开始，可以理解为数据信号消失后还要一段时间才能结束，就是为了等存取周期结束



### 半导体存储芯片简介

#### 半导体存储芯片的基本结构

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406094018508.png" alt="image-20220406094018508" style="zoom:67%;" />

片选线：该芯片是否被选中，比如内存条上由多个芯片组成，cs低电平表示被选中

读/写控制线：分一条线控制或者两条线控制



#### 存储器片选线的作用

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406094946270.png" alt="image-20220406094946270" style="zoom: 67%;" />

#### 半导体存储芯片的译码驱动方式

##### 线选法

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406100240581.png" alt="image-20220406100240581" style="zoom:67%;" />

缺点在于容量一大， 需要在内存中高度集成，比较困难





##### 重合法

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406103229498.png" alt="image-20220406103229498" style="zoom:67%;" />

将存储单元从线选法的一维数组转变为二维数组，可以减少集成度

### 随机存取存储器（RAM）

#### 静态RAM

运用触发器保存0和1，电路结构，读，写操作都是逻辑电路，不做关注了

#### 动态RAM

利用电容保存0和1，电容会漏电

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406105241267.png" alt="image-20220406105241267" style="zoom:67%;" />

读写也涉及数字逻辑电路，不做关注

#### 动态RAM刷新

##### 集中刷新：每一次刷新一行

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406193335290.png" alt="image-20220406193335290" style="zoom:67%;" />

在刷新时间间隔内，前3872个周期可以正常读取，后128周期内进行刷新，无论是CPU还是I/O进行数据交换，为死区，只能等待

##### 分散刷新

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406195218627.png" alt="image-20220406195218627" style="zoom:67%;" />

Tm就是0.5us，原先的存取周期，TR是对某一行的刷新时间，两个合起来变成新的存取周期，就是1us，相对于集中刷新的2ms时间内，128行刷新了15.6次，就有些频繁

##### 异步刷新（分步刷新与集中刷新相结合）

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406200150941.png" alt="image-20220406200150941" style="zoom:67%;" />

集中刷新是每一次存取周期后就刷新一行，异步刷新是多个存取周期后刷新一行，依然以2ms为界，要在2ms内完成128行的刷新，分成128份，每份15.6us，15.6us的某一个存取周期中进行刷新，这样2ms就能刷新128次

死区为15.6us中的某一个0.5us的周期，但是控制得好可以没有死区

#### 动态RAM和静态RAM的比价

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406203656672.png" alt="image-20220406203656672" style="zoom:67%;" />

内存用的是DRAM，缓存用的是SRAM 

### 只读存储器（ROM）

#### 只读存储器的发展历程

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406205420655.png" alt="image-20220406205420655" style="zoom:67%;" />

#### 掩模ROM（MROM）

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406205853197.png" alt="image-20220406205853197" style="zoom:67%;" />

这种存储器就是厂家事先写好的

#### PROM（一次性编程）

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406205945331.png" alt="image-20220406205945331" style="zoom:67%;" />

厂家未写好，可以自己写，但只能写依次，0的地方用大电流烧断，破坏性编程

#### EPROM（多次性编程）

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406210309313.png" alt="image-20220406210309313" style="zoom:67%;" />

紫外线擦写

#### EEPROM（多次性编程）

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406210457418.png" alt="image-20220406210457418" style="zoom:67%;" />

电可擦写
