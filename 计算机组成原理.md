#  计算机基本组成

### 存储器

​	存储字长：存储单元的长度

​	存储器：存储体，MDR，MAR

​	MDR：保存从存储体取出或者将要存入的数据，位数体现存储单元长度

​	MAR：保存存储体的地址，位数体现存储单元的地址容量

### 指令

操作码+存储地址，指令和数据都以二进制位存储在存储体当中，不作区分

### 运算过程

ALU直接实现了加法和除法，直接实现乘法和除法代价较高

#### 加法操作过程

​                                           、<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220328095251329.png" alt="image-20220328095251329" style="zoom: 50%;" />   

#### 减法操作过程

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220328095513017.png" alt="image-20220328095513017" style="zoom: 50%;" />

#### 乘法操作过程

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220328095918906.png" alt="image-20220328095918906" style="zoom: 50%;" />

乘法操作原理：

为什么ACC要清零：之后要完成累加操作，所以要清零

ACC放的是被乘数，先将其转移到X中，乘数放在MQ中，两者相乘，ACC放结果高位，MQ放结果低位

#### 除法操作过程

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220328101000923.png" alt="image-20220328101000923" style="zoom:50%;" />

除法操作原理：被除数减除数，最后的余数放在ACC中，商放在MQ当中

<u>为什么这里的MQ不先清零？？？</u>

加减乘除底层的逻辑电路实现这里先不深究



### 控制器

#### 控制器的功能

解释指令：解释指令指的是从取指到执行到保存结果一系列的过程

保证指令的按序执行

完成指令的过程：

1.取指令，控制器执行，体现在PC

2.分析指令，控制器执行

3.执行指令，控制器执行



### 衡量计算机硬件性能

#### 指令周期：

计算机取出并执行一条指令的时间。

#### CPU周期（亦称机器周期）：

一条指令执行过程被划分为若干阶段，例如，取指令、[存储器](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%99%A8/1583185)读、存储器写等，这每一项工作称为一个基本操作（注意：每一个基本操作都是由若干CPU最基本的动作组成）。完成一个**基本操作**所需要的时间称为机器周期。通常用内存中读取一个字的最短时间来规定CPU周期。

#### 时钟周期：

又称震荡周期，是处理操作的最基本单位。为什么需要时钟周期，主要是用于同步，比如CPU从内存中读8位的数据，放到寄存器中，8位同时读，肯定不可能同时到达，就会出现错误，如果这个错误的数据拿去运算，错误会放大，所以需要一个时钟，让读取这个动作发生在电压的上升沿，其余时间将各个电平保持，也就是说，确保8位数据在这个时间周期内能够读到寄存器上，除此之外，还有加法器的例子：

![image-20220330094728397](C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220330094728397.png)

两个输入，然你输出相加结果，这个过程需要时间，如果没有时钟，可能只有几位变化，有些加法器可能需要多个时钟周期才能确保最后结果正确

即一个指令周期，包含多个 CPU 周期，而一个 CPU 周期包含多个时钟周期。

#### 以运算器为中心的冯诺依曼结构

输入输出的信息到达存储器需要算数逻辑单元ALU参与

#### 以存储器为中心的冯诺依曼结构

输入输出的信息到达存储器不需要算数逻辑单元ALU参与

所谓的指令集，就是软硬件的接口

#### 汇编语言和高级语言

汇编语言指令集不同，则原先汇编，转成机器码就不能实现了，需要重新设计一套符号和机器码的对应形式，不同指令集，机器码就不一样，原先的对应关系就失效了，需要重新设计

高级语言会被编译器编译成不同Cpu指令集对应的汇编语言，所以他不用考虑底层的硬件，即相当于根据不同平台给你转成不同的汇编

![image-20220329103244957](C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220329103244957.png)

同一个操作，实现的指令步骤或者对应的机器码是不一样的，原先的汇编语言翻译后面临机器码对不上的问题，如果指令步骤完全一致，知识机器码的差别，或许可以修改汇编器，将其指向另一种体系结构对应的机器码，但是也有可能指令步骤也完全不一样，这样就没有办法转



## 总线

各个部件**共享**的传输介质

串行：单根数据线，一个位一个位进行传输

并行：多根数据线，多个位同时进行传输，长距离的情况下线之间会发生干扰，导致出错

### 总线结构

#### 单总线结构

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220329105409174.png" alt="image-20220329105409174" style="zoom: 67%;" />

每次只能一对设备用，造成计算机瓶颈，如果设备数量较多，总线长度过长

#### 面向CPU的双总线结构

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220329105703630.png" alt="image-20220329105703630" style="zoom:67%;" />

相当于CPU单独连接主存，问题在于一旦主存和I/O设备之间存在数据交换，都要通过CPU，CPU原先的操作都会被打断

#### 面向存储器的双总线结构

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220329144242729.png" alt="image-20220329144242729" style="zoom:67%;" />

主存可以直接和I/O接口进行连接，但是按照现在的技术，主存在存储总线以及主存在系统总线上的数据传输不能同时进行



### 总线的分类

#### 片内总线：芯片内部之间的总线

#### 系统总线（可以理解成片间总线）：计算机各部件之间的信息传输线

1.数据总线：机器字长为64位，存储字长为8位，一般来说，数据总线宽度小于等于这两者，这样传一个64位的数据就要传8次，数据总线是双向的

2.地址总线：与存储器中的MDR位数长度一样，是单向的

3.控制总线：类似外设端口发送给CPU的中断信号也是通过控制总线进行传输的

#### 通信总线（从计算机内部扩展到计算机外部）

计算机系统之间或者计算机系统与其他系统之间的通信

传输方式：串行通信总线，并行通信总线

### 

### 总线性能及性能指标

在计算机中表现就是一根根并列的印刷电路板，上面留出了很多接口，很多插板可以插上去

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220329145355340.png" alt="image-20220329145355340" style="zoom:67%;" />



#### 总线特性：

机械特性：尺寸、形状、管脚数及排列顺序

电气特定：数据传输方向和有效的电平范围

功能特性：每根传输线的功能

时间特性：时序电路信号的时序 不懂



#### 总线的性能指标

 总线宽度：数据线的根数

标准传输率：每秒传输的最大字节数（MBps）

时钟同步/异步：同步、不同步

总线复用：地址线和数据线复用，8086就是这样的结构，20位地址可以用来传输地址，然后16位用来传输数据

信号线数：地址线、数据线和控制线的总和

总线控制方式：突发、自动、仲裁、逻辑、计数

其他指标：负载能力，比如总线上可以挂载多少个I/O设备



#### 总线标准

不同厂商生产的配件要能接到同一条总线上，所以要有标准

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220329152136260.png" alt="image-20220329152136260" style="zoom:67%;" />

总线时钟的8Mhz，每秒传输8M次，数据线16位，一次传输两个字节，所以每秒传输字节数 8M * 2，就是16MBps

涉及到频率，以及带宽，之间的进制转换是1000

总线频率体现的是数据传输速率，即总线频率 * 数据线 / 8就是每秒能传输多少数据（总线的同步通过外频控制？）

而时钟频率是用来同步的，两者不是一个概念

### 总线判优控制

主设备：对总线有控制权

从设备：响应从主设备发来的总线命令

总线判优：集中式（链式查询、计数器定时查询、独立请求方式），分布式  

#### 链式查询

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220331160717654.png" alt="image-20220331160717654" style="zoom:67%;" />



BG是一个一个地向下进行查询，碰到第一个提出请求的设备，是事先决定好的

优点：结构简单

缺点：在于如果一个出问题了，后面所有的都不能得到总线了，对电路故障特别敏感

用在微型计算机或者嵌入式系统

资料：“当有设备想用总线时，会往BR发送信号，总线控制器收到信号后会发送BG信号。如果有两个设备同时请求，那么次序靠前的会优先收到BG信号，并对其进行拦截。同时它还往BS发送信号，**当总线控制器收到BS信号后，就不再理会是否有设备请求使用总线了**。直到该设备用完总线后，撤销BS信号。”

#### 计数器定时查询



<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220331164806859.png" alt="image-20220331164806859" style="zoom:67%;" />

工作原理：总线控制部件中存在计数器，计数器的值通过设备地址这条线输出，去查询相应的I/O接口，如果不是，计数器的值加1，查询下一个，可以控制计数器的值，从而改变I/O设备的优先级，与链式查询相比，区别在于少了BG线，多了设备地址线。

设备地址线：位数由设备数决定，如果有n个设备，地址位数至少需要logn向上取整

#### 独立请求方式

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220331170046650.png" alt="image-20220331170046650" style="zoom:67%;" />

要求的线数较多，如果有n个设备，需要2*n条线

<u>为什么独立请求方式不用bs线呢？是因为总线控制部件里面有优先级，所以就算一个I/O接口获得了总线，只要一个优先级比它高的I/O接口发起请求就能立马中断？</u>



### 总线通信控制

#### 总线传输周期（一个完整的传输过程）：

申请分配阶段：主模块申请，总线仲裁决定

寻址阶段：主模块向从模块给出地址和命令

传数阶段：主模块和从模块交换数据

结束阶段：主模块撤销有关信息

#### 总线通信的四种方式

##### 同步通信：

定宽定距的时钟来控制整体的同步

##### 同步式数据输入

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220401145959549.png" alt="image-20220401145959549" style="zoom:67%;" />

第一个时钟周期，给出地址信号，第二个时钟周期，给出读控制信号，第三个时钟周期，I/O设备给出数据，第4个周期，数据信号和读控制信号消失，第四个周期结束，地址信号消失。

这里一个时钟周期可能发生多件事，比如读命令发出后到T3周期前，完成了读命令的传输，存储器将数据放到数据总线上，比如给出地址信号，就是地址信号从CPU到I/O设备（或者还包括存储器用这个地址去找的过程），给出数据信号，就是数据信号从I/O设备到CPU，为什么要用时钟，比如地址信号给出两个周期后I/O才给数据，这是为了地址的数据在这个时间内能够到达，这样给的数据才是对的，同理为什么要一个时钟周期后数据信号才能消失，这是为了确保数据能完整地到达CPU，如果没有时钟，很多时候不能确定上一步的数据是否正确，下一步的数据有时候要依靠上一步的数据，或者数据传输过程中可能有问题。

##### 同步式数据输出

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220401153439624.png" alt="image-20220401153439624" style="zoom:67%;" />

可以看出传输数据主要花差不多半个周期，写命令需要两个周期，则可以将同步输入时的图理解为T2的前半个周期读命令传输到存储器，后半个周期准备数据到数据总线上

##### 异步通信

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220401153948351.png" alt="image-20220401153948351" style="zoom:67%;" />

时钟是为了确保在这个时间内，相应的信号能到达目的地，比如发邮件咨询，一周后查看，因为确认一周内一定会回复，异步就相当于发邮件，邮件客户端提示你对方有回件，再进行查看



##### 半同步通信

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220401160133910.png" alt="image-20220401160133910" style="zoom:67%;" />

在第三个周期上升沿将要到来时，应该完成读命令到达内存，内存将相应的数据放到数据总线上，但是因为内存的速度差异，可能还没准备好，会设置一个wait信号为低电平，在第三个时钟周期的上升沿，CPU检测这个信号，如果为低电平就多给一个Tw的准备时间，直到检测到高电平，就可以去数据总线总线上读数据

##### 分离式通信

为了充分挖掘系统每个瞬间的潜力

一个总线传输周期

子周期1：主模块申请占用总线，使用完后立即放弃总线的使用权

子周期2：从模块申请占用总线，将各种信息送至总线上

与之前相比，之前主模块一直占用总线，主模块和从模块之间进行数据传输，分离式通信子周期2从模块将变成主模块

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220401161329975.png" alt="image-20220401161329975" style="zoom:67%;" />

从模块变成主模块后传输数据也是按照同步，即给地址，给数据，给写命令等

<u>为什么地址总线的信号要多维持一个周期？</u>

### 存储器

#### 按照存取方式分类

（1）存取时间与物理地址无关（随机访问，即随意一个地址找到的时间都一样，被称为随机存储器）

随机存储器（这个“随机存储器”与上面的随机存储器不是一个概念，历史遗留问题）：在程序的执行过程中可读可写

只读存储器：在程序的执行过程中只读



（2）存取时间与物理地址有关（串行访问）

顺序存取存储器：磁带

直接存取存储器：磁盘（比如机械硬盘）



#### 按照在计算机中的作用分类

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220403101534950.png" alt="image-20220403101534950" style="zoom:67%;" />

Flash Memory一般指高性能的U盘和固态硬盘ssd



#### 存储器的层次结构

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220403102419243.png" alt="image-20220403102419243" style="zoom:67%;" />

缓存一部分在CPU内部，一部分在CPU外部，是因为要提升速度，但是技术限制已经不能在CPU中大量增加缓存的数量，就把它放在了外面

#### 层次结构

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220403103116372.png" alt="image-20220403103116372" style="zoom:67%;" />

要把存储器组合成整体来看，将主存缓存看做一个整体，是因为程序有时候过大，超过了主存的上限，将其看做一个整体可以解决容量不足的问题，对应主存-辅存层次，将缓存和主存看做一个整体，是为了解决主存和CPU之间速度不匹配的问题，被称为缓存-主存层次。

在找缓存中的内容时，使用的是主存的地址（这里应该是实际地址，实地址，物理地址），映射到缓存中的位置

在找主存中的内容时，使用虚地址，是从0开始的逻辑地址，找的时候将其转化为实际地址



### 主存储器

#### 主存的基本组成

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220403105230998.png" alt="image-20220403105230998" style="zoom:67%;" />

#### 主存和CPU的联系

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220403105411952.png" alt="image-20220403105411952" style="zoom:67%;" />

MDR和MAR逻辑上属于主存，物理上属于CPU

#### 主存中存储单元地址的分配

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220403110610806.png" alt="image-20220403110610806" style="zoom:67%;" />

存放一个机器字的存储单元，通常称为字存储单元，相应的地址称为字地址，存放一个字节的单元，称为字节存储单元，相应的地址称为字节地址

#### 主存的技术指标

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220403110928911.png" alt="image-20220403110928911" style="zoom:67%;" />

存取周期的开始节点是将数据存入存储器（给出地址信号开始）的时间+下一次能够再执行这个存操作的时间，存取周期的倒数乘每次读取的位数可以算出带宽

存取时间就单纯是指数据存入存储器的时间（给出地址信号开始，数据到达预定的位置结束），所以存储周期大于存储时间

总线周期中包含了存取时间，一次总线周期要么存，要么读，所以肯定要这个存取周期结束了，下一个总线周期才能开始，可以理解为数据信号消失后还要一段时间才能结束，就是为了等存取周期结束



### 半导体存储芯片简介

#### 半导体存储芯片的基本结构

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406094018508.png" alt="image-20220406094018508" style="zoom:67%;" />

片选线：该芯片是否被选中，比如内存条上由多个芯片组成，cs低电平表示被选中

读/写控制线：分一条线控制或者两条线控制



#### 存储器片选线的作用

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406094946270.png" alt="image-20220406094946270" style="zoom: 67%;" />

#### 半导体存储芯片的译码驱动方式

##### 线选法

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406100240581.png" alt="image-20220406100240581" style="zoom:67%;" />

缺点在于容量一大， 需要在内存中高度集成，比较困难





##### 重合法

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406103229498.png" alt="image-20220406103229498" style="zoom:67%;" />

将存储单元从线选法的一维数组转变为二维数组，可以减少集成度

### 随机存取存储器（RAM）

#### 静态RAM

运用触发器保存0和1，电路结构，读，写操作都是逻辑电路，不做关注了

#### 动态RAM

利用电容保存0和1，电容会漏电

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406105241267.png" alt="image-20220406105241267" style="zoom:67%;" />

读写也涉及数字逻辑电路，不做关注

#### 动态RAM刷新

##### 集中刷新：每一次刷新一行

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406193335290.png" alt="image-20220406193335290" style="zoom:67%;" />

在刷新时间间隔内，前3872个周期可以正常读取，后128周期内进行刷新，无论是CPU还是I/O进行数据交换，为死区，只能等待

##### 分散刷新

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406195218627.png" alt="image-20220406195218627" style="zoom:67%;" />

Tm就是0.5us，原先的存取周期，TR是对某一行的刷新时间，两个合起来变成新的存取周期，就是1us，相对于集中刷新的2ms时间内，128行刷新了15.6次，就有些频繁

##### 异步刷新（分步刷新与集中刷新相结合）

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406200150941.png" alt="image-20220406200150941" style="zoom:67%;" />

集中刷新是每一次存取周期后就刷新一行，异步刷新是多个存取周期后刷新一行，依然以2ms为界，要在2ms内完成128行的刷新，分成128份，每份15.6us，15.6us的某一个存取周期中进行刷新，这样2ms就能刷新128次

死区为15.6us中的某一个0.5us的周期，但是控制得好可以没有死区

#### 动态RAM和静态RAM的比价

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406203656672.png" alt="image-20220406203656672" style="zoom:67%;" />

内存用的是DRAM，缓存用的是SRAM 

### 只读存储器（ROM）

#### 只读存储器的发展历程

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406205420655.png" alt="image-20220406205420655" style="zoom:67%;" />

#### 掩模ROM（MROM）

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406205853197.png" alt="image-20220406205853197" style="zoom:67%;" />

这种存储器就是厂家事先写好的

#### PROM（一次性编程）

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406205945331.png" alt="image-20220406205945331" style="zoom:67%;" />

厂家未写好，可以自己写，但只能写依次，0的地方用大电流烧断，破坏性编程

#### EPROM（多次性编程）

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406210309313.png" alt="image-20220406210309313" style="zoom:67%;" />

紫外线擦写

#### EEPROM（多次性编程）

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220406210457418.png" alt="image-20220406210457418" style="zoom:67%;" />

电可擦写

### 存储器与CPU的连接

#### 存储器容量的扩展

##### 位扩展：比如1位的存储单元拼成8位的的存储单元

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220407100845424.png" alt="image-20220407100845424" style="zoom:67%;" />

存储器位扩展的时候是否需要将地址线和数据线按序连接？

地址线不需要，接收到的地址都是这个地址，数据线需要，两个2114芯片按照不同顺序读出来的数据分为高位低位，会产生大端小端的差别

##### 字扩展

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220407102901121.png" alt="image-20220407102901121" style="zoom:67%;" />

1K需要10根地址线，包括A0-A9，现在将两个1K的芯片拼在一起，就会多出一条A10，总共是11条地址信啊，A10为0，选择第一个芯片，A10为1，选择第二个芯片，A10这根地址线多出来做片选信号

每个芯片的8位数据线连接到D0-D7的数据输出上，两个芯片不能同时工作，因为一共只有8位

##### 字、位扩展

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220407144051119.png" alt="image-20220407144051119" style="zoom:67%;" />

多出来的两条地址线做通过译码器做片选，同时连到两个芯片上，这样就扩展成8位

怎么确定地址线和数据线的位数，看最后需要的寻址空间和存储字长的位数（存储字长即为MDR的位数，存储单元的位数，这里MAR寻址时不考虑字长，比如存储字长为4,001到002地址之间就隔了4个bit，如果存储字长为8，就隔了8位）

### 存储器和CPU的连接

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220407152948123.png" alt="image-20220407152948123" style="zoom:67%;" />

写出需要的地址范围，可以看出系统系统空间需要2K的寻址空间，即11根地址线，用户空间需要1K的寻址空间，即9根地址线

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220407152728740.png" alt="image-20220407152728740" style="zoom:67%;" />

那么A0-A10连接2Kx8位的芯片，A0-A9连接两片1Kx4的芯片，138译码器有三个输入端，三个控制端，因此三个输入端接A11-A13，当输出端为4时，选择2Kx8的地址，当输出端为5时，选择两片1Kx4的芯片，观察前面的地址范围可以只知道A15一直是0，A14一直是1，而138译码器的控制端需要G1一直是高电平，G2A和G2B一直是低电平，所以A14连接G1，本来应该A15同时连接G2A和G2B就行，但是还多出来一个MREQ信号，这个信号为低电平表示存储器被选中，否则就是选中的I/O，将它接在G2B上，如果MREQ是高电平，那么译码器不工作，Y0-Y7都是高电平，芯片没有片选，就不会寻找到存储器的地址。

还有一点需要注意，当译码器输出信号为5时，选择两片1Kx4的芯片，看地址这个时候的A10位为0，所以两个同时成立的时候才能表示，选中了两片1Kx4

为什么不直接不管A10位，只用Y5的输出的片选信号呢？

因为逻辑上来说虽然这时候的片选信号选中了这个芯片，但是如果A10置1，这个逻辑上的地址不在这个芯片内，但是却找到这个芯片里去了

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220408105743235.png" alt="image-20220408105743235" style="zoom:67%;" />

如果用8kx8位的芯片要怎么做

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220408105908929.png" alt="image-20220408105908929" style="zoom:67%;" />

不确定，最后三位做片选，当片选信号为0且A12位0选4K芯片，当片选信号为0且A12位为0选8K芯片，当盘旋信号为1且A12位为1选8K芯片？

### 存储器的校验

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220408152157889.png" alt="image-20220408152157889" style="zoom:67%;" />

编码的检测能力和纠错能力与合法代码之间的差异有关，这被定义为代码之间的最小差异

如果最小差异为奇数，那么能检测到的错误就是1-n/2(舍去0.5）,再增大改变的数目又能归类到1-n/2 ，同时能纠正的也就是1-n/2，所以检错能力为n/2，纠错能力为n/2，总共加起来为n-1

如果最小差异数为偶数，那么能检测到的错误就是1-n/2(不用舍去0.5),同上，但是n/2的时候不知道是这半部分出问题，还是余下的半部分出问题，所以纠错能力只有n/2 - 1，总共加起来为n-1

所以最小差异数为n时，检错能力和纠错能力加起来总是为n-1

#### 编码的最小距离

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220411091851306.png" alt="image-20220411091851306" style="zoom:67%;" />

#### 汉明码的组成

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220411192827800.png" alt="image-20220411192827800" style="zoom:67%;" />

奇偶校验：奇校验，加上校验位，使1的个数为奇数个；偶校验，叫上校验位，使1的个数为偶数个

怎么校验，用异或实现，比如奇校验，各位进行异或，最终预期的结果应该是1；偶校验，各位进行异或，最终预期的结果应该是0

上图进行偶校验，首先对各位的数字进行分组，分成了三组，然后对各组进行校验，可以发现，校验结果正好显示出错的位置，这就是通过分组得到的，即我们应该选择怎么样的分组，来达到这样的效果

分组原则：将位置的二进制代码写出来，可以发现，从最右侧开始，第一组的第一位都是1，第二组的第二位都是1，第三组的第三位都是1，同理，第四组的第四位都是1，第五组的第五位都是1，也就是说给一个位置，我们通过它是否在每一组，写出每一位是1还是0，就可以得到这个位置

那么这样分组造成的结果就是，比如第一组出错，那么该位置就是在第一组，从右往左第一位置1，刚好契合校验出来的1放在最右端，第二组出错，那么该位置的就是在第二组，该位置的二进制代码从右往做第二位就是1，刚好契合校验出来的1放在从右往左第2个位置，所以校验的结果按照组别从右开始从小到大排列，就是该位置的二进制代码



#### 检测位三要素

##### 需添加几位检测位？

原先有n为，加上检测位k位，就是分成k组，那么可能的表示状态为2的k次，要能够覆盖n+k位置出现的错误，还包括一个没有错的情况，即n+k+1

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220411195447606.png" alt="image-20220411195447606" style="zoom:67%;" />

##### 检测位的位置

约定俗成为2的i次，第i组就是2的i-1次

##### 检测位的取值

一般为偶校验

#### 实例

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220411202727624.png" alt="image-20220411202727624" style="zoom:67%;" />

异或为1，为奇数个1，所以校验位为1；异或为0，为偶数个1，所以校验位为0，刚好对应异或结果，所以可以用异或结果来求校验位的值

汉明码的纠错

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220411203117839.png" alt="image-20220411203117839" style="zoom:67%;" />

偶校验不出错时异或都为0

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220411205306343.png" alt="image-20220411205306343" style="zoom:67%;" />

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220411210436480.png" alt="image-20220411210436480" style="zoom:67%;" />

奇校验的汉明码纠错时只要将校验码取反就能找到位置

##### 汉明距离

<u>先不关注了</u>



### 提高访存速度的措施

#### 单体多字系统

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220412093107875.png" alt="image-20220412093107875" style="zoom:67%;" />

CPU机器字长16位，存储字长64位，CPU一次读取64位数据放入4个16位组成的数据寄存器中，再从中选出自己需要的16位指令或者数据放到单机器字长寄存器中，这样下一条指令可以直接在数据寄存器中取

问题：

1.取指令时，有可能不是相邻的指令，比如第一个指令是跳转指令，这样只有一条指令时有效的

2.写入时，先放入单字长寄存器，再放入数据寄存器，一次只写入16位，另外48位将存储器相应位置的值修改，这种修改是错误的

#### 多体并行系统（高位交叉）

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220412094033517.png" alt="image-20220412094033517" style="zoom:67%;" />

虽然存在并行的基础，但是大部分指令都是相邻的，所以CPU读指令会造成一个存储体过于繁忙，其他存储体空闲（就和一个存储体差不多），所以适合容量进行扩展，但是不适合提高存取速度

#### 多体并行系统（低位交叉）

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220412095119475.png" alt="image-20220412095119475" style="zoom:67%;" />

这样编址连续的指令会依次在M0，M1，M2，M3中出现，这里采用的是分离式通信，CPU申请总线的使用权，发送地址，发送控制信号，然后放弃总线的使用权，存储体去读，CPU还可以再申请总线，发送地址，发送控制信号给其他的存储体，然后放弃总线的使用权，当存储体准备好数据之后申请总线使用权，将数据传给CPU

#### 低位交叉的特点

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220414153919439.png" alt="image-20220414153919439" style="zoom:67%;" />

这里的总线传输周期就是存取时间，在一个存取周期内，CPU在存取时间完成依次读写操作，但是再一次读取需要存取周期结束，在这个时间内可以申请对其他存储体的访问，形成流水线

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220414153943615.png" alt="image-20220414153943615" style="zoom:67%;" />

为了实现流水线，比如存取周期为T，存取时间为t，那么我们就可以低位交叉选择 T/t个存储体

如果是k个存储单元，就是T+（k-1）t

### 高速缓冲存储器

Cache要起到作用，就要保证要取的数据大部分都在Cache中，需要程序访问的局部性原理



1.时间局部性：当前正在使用的指令或数据在不久的将来还会再使用

2.空间局部性：当前正在使用的指令或数据在不久的将来相邻的指令或数据还会再使用

所以Cache中主要存正在使用的指令和数据以及响相邻的指令或数据



#### Cache的工作原理

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220414152220852.png" alt="image-20220414152220852" style="zoom:67%;" />

实际上没有缓存地址，只有主存的地址，如果一个主存块被写到Cache当中，就在Cache之前的标记写入主存块号，CPU读取时把给出地址的主存块号和标记进行比较

#### 命中与未命中

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220414152805916.png" alt="image-20220414152805916" style="zoom:67%;" />

#### Cache的命中率

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220414153151400.png" alt="image-20220414153151400" style="zoom:67%;" />

有n1次访问到了指令，有n2次没有访问到，命中率就是n1/(n1+n2)

命中率与Cache的容量有关，比如Cache的容量越大，和主存相等，除了第一次不能命中，后面每次都能命中；块长过小，没几步指令就要新的块，就可能没命中，没有充分利用程序的局部性原理；块过大，Cache的容量是有限的，块数比较少，一个块中可能只有几条指令要用到，就要加载新的块

### 主存系统的效率

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416142151667.png" alt="image-20220416142151667" style="zoom:67%;" />

平均访问时间是指，访问n次，命中Cache的次数n*h，没命中Cache的次数n*（1-h），所以平均依次的访问时间（n*h*Tc + n*（1-h）*Tm） / n,简化就是图中平均访问时间的公式，主存的访问时间包括去寻找访问Cache未命中的时间和未命中后访问主存的时间

注意，可以看出CPU访问Cache和访问主存是并行的，在访问Cache的同时也在访问主存，如果Cache先找到，立即返回数据，如果Cache没有，此时主存也一直在找，主存返回数据。如果访问Cache和访问主存是串行的，访问主存的时间就要加上Tc

<u>没命中访问主存不是还要把数据写到Cache中么？这个时间不用加上么</u>（没命中时去主存中找数据，同时也会将数据装载入Cache的相应位置）

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416195335425.png" alt="image-20220416195335425" style="zoom:67%;" />

没有命中Cache也要先访问，拿出数据进行判断，所以也要花Tc时间

同时访问Cache和主存，访问没命中时，主存访问已经进行一部分了，继续就行，给出数据的同时还会把相应的块装载入Cache中

#### Cache的基本结构

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416143735970.png" alt="image-20220416143735970" style="zoom:67%;" />

映射：确定要查找的主存在Cache中的位置

变换：将主存的块号转变为Cache中的块号

直接通路负责主存和Cache中的数据交换，替换算法就要用到

#### Cache的读操作

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416195806727.png" alt="image-20220416195806727" style="zoom:67%;" />

没命中时去主存取与Cache替换同时进行

Cache替换是否满是指该块放的地方是否满，而不是Cache整体是否满

一般来说访问Cache和访问主存是同时进行的

#### Cache的写操作

面临不一致问题，Cache和主存的一致性

##### 写直达法

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416203235479.png" alt="image-20220416203235479" style="zoom:67%;" />

优点是Cache和主存一直保持一致，可能造成CPU对同一个内存单元反复地写，如执行求和，每一次赋到一个内存地址，就要重新写，实际上只要取最后一次再写就行

##### 写回法

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416203420579.png" alt="image-20220416203420579" style="zoom:67%;" />

无法实时保持一致，比如多处理器每个Cache里都有一个副本



#### Cache的改进

增加Cache的级数

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416203635605.png" alt="image-20220416203635605" style="zoom:67%;" />

一般CPU内部2片，CPU外部主板上1片，所以至少有3级

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416203728246.png" alt="image-20220416203728246" style="zoom:67%;" />

### 地址映射

#### 直接映射

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416204657707.png" alt="image-20220416204657707" style="zoom:67%;" />

很多存储字组成一个块，很多块组成一个区，组成区的块数量就根据Cache中的来，主存由这样一个一个区组成，给出主存地址，可以得到Cache自块地址，这里一个区的大小是2的c次方，所以Cache字块地址只能是0-2的c次方减1，然后直接映射到Cache的相应位置，主存字块标记说明了是第几个区，和Cache中的标记比较就能知道当前块是否是选中的块

c决定了一个区内是哪个块，t决定了这个块是哪个区的

#### 全相连映射



<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416205538108.png" alt="image-20220416205538108" style="zoom:67%;" />

全相连映射就是块可以放到Cache存储器中的任何一个块中，只要有空位，那么t+c实际上就是字块的数量，也就是m，在给出主存地址时，需要比较Cache存储器中的所有块，看是否标记相同，标记的位数也会变长

直接映射和全相连映射走了两个极端，直接映射的块只能放到一个位置，全相连映射的块可以放到任意位置，组相连映射结合了两者

#### 组相连映射

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416211453828.png" alt="image-20220416211453828" style="zoom:67%;" />

本来是将主存储器中数量为Cache块数量的作为一个区，现在是将Cache中的块分组，位数为r，所以分出来的组为2的c-r次，将主存中2的c-r个块作为一个区，将组地址映射到某个组中，然后组中可以随便映射，比对标记即可

从位数上看，后面的s中的r位决定了组中的第几列，s中的t决定了原来区大小是哪个区，一方面需要确定是在组中的哪个位置，另一方面需要确定原来区大小的是哪个区，所以需要t+r位，实际上在组内的映射是无序的

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416212509527.png" alt="image-20220416212509527" style="zoom:67%;" />

距离CPU近的，要求速度，可以用直接映射，距离CPU远的，对速度要求不高，可以用全相连，中间的可以用组相连，直接映射速度快，只要命中，马上就能找到位置拿数据，但对CPU的利用率不高，全相连对CPU利用率高，但是每个都要比较，速度比较慢



#### 替换算法

主要针对全相连和组相连

##### 先进先出（FIFO）算法

有可能被替换出去的块马上要用到，不符合程序的局部性原理

##### 近期最少使用（LRU）算法

#### 小结

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416214843807.png" alt="image-20220416214843807" style="zoom:67%;" />

### 辅助存储器

不直接与CPU交换数据（硬盘、U盘、光盘等）

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416220416939.png" alt="image-20220416220416939" style="zoom:67%;" />

越往外位密度越低

n是盘面数，k是磁道数，s是每个磁道存放的二进制信息

#### 磁记录原理

物理原理不关注了

##### 写

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416220812106.png" alt="image-20220416220812106" style="zoom:67%;" />

##### 读

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416220734784.png" alt="image-20220416220734784" style="zoom:67%;" />

#### 硬磁盘存储器

##### <img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416221229006.png" alt="image-20220416221229006" style="zoom:67%;" />

固定磁头每个磁道都有个磁头

##### 磁盘控制器

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416221426577.png" alt="image-20220416221426577" style="zoom:67%;" />

##### 盘片

硬质铝合金结构

#### 软磁盘存储器

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416221737109.png" alt="image-20220416221737109" style="zoom:67%;" />

#### 光盘存储器

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220416222010992.png" alt="image-20220416222010992" style="zoom:67%;" />

### 输入输出系统

接口：

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417134908116.png" alt="image-20220417134908116" style="zoom:67%;" />

接口的功能：

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417134942472.png" alt="image-20220417134942472" style="zoom:67%;" />

#### 输出输入系统的发展

##### 分散连接

每个I/O设备单独与CPU相连，采用程序查询方式，串行工作（I/O进行数据输入输出的时候CPU必须运行相应程序或者停）

##### 接口模块和DMA阶段

总线连接

CPU和I/O设备并行工作 ，分为中断方式和DMA方式

##### 具有通道结构的阶段

通道可以看做一个微型处理器或者DMA控制器

##### 具有I/O处理机的阶段



#### 输入输出系统的组成

##### I/O软件

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417135848546.png" alt="image-20220417135848546" style="zoom:67%;" />

操作码就可以指出是I/O指令，命令码就是一般指令的操作，设备码是I/O设备的地址

##### I/O硬件

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417135950366.png" alt="image-20220417135950366" style="zoom:67%;" />

两种方式，一种是外部设备通过I/O接口连接总线，总线连接主机；另一种是通道方式，I/O设备连接设备控制器，设备控制器连接子通道，子通道再连接通道

### I/O设备与主机的联系方式

#### I/O设备的编址方式

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417140616855.png" alt="image-20220417140616855" style="zoom:67%;" />

##### 统一编制

将主存的一部分地址看做是I/O设备的地址或者是端口的地址，如果指令的地址码部分落到了I/O指令的地址区，就知道是针对I/O设备，指令也就是一般的取数、存数指令，适用于内存空间比较大的系统

##### 不统一编制

比如主存编制20位，就是1M，I/O设备编制16位，64K，一个地址不能区分是主存的还是I/O设备的，所以有专门的I/O指令

#### 设备选址

用设备选择电路识别是否被选中，将CPU给出的地址和I/O设备自己保存的地址进行比较，相同即被选中

#### 传送方式

串行：一条线，一次传一位

并行：多条线，一次传多位

#### 联络方式

##### 立即响应

接收到输入数据之后立即显示，比如LED灯接收到输入后立刻可以用亮或者不亮表示接收到的数据值

##### 异步工作采用应答信号

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417141707723.png" alt="image-20220417141707723" style="zoom:67%;" />



这里的并行指的是一次传输多位数据，CPU输出时，I/O接口的端口准备好数据，向I/O设备发送ready信号，I/O设备接收到ready信号后，读取数据，读取完毕发送strobe应答信号；CPU输入时，I/O接口端口为空，向I/O设备发送Ready信号，告诉它可以输入，I/O设备输入完成后发送应答信号

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417142722729.png" alt="image-20220417142722729" style="zoom:67%;" />

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417142045762.png" alt="image-20220417142045762" style="zoom:67%;" />

串行只有一根线，通过开头和结束时两个低or高电平告诉对方开始与结束，实现异步

##### 同步工作采用同步时标

定宽定距的时钟来控制某个动作必须在某一时刻开始，在某一时刻完成，如外部设别以2400hz的频率传输数据到接口，CPU也就必须1/2400s到接口取一次数据

#### I/O设备和主机的联系方式

##### 辐射式连接（就是之前的分散连接）

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417143227063.png" alt="image-20220417143227063" style="zoom:67%;" />

##### 总线连接

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417143423985.png" alt="image-20220417143423985" style="zoom:67%;" />

接口有一定的标准，只要外部设备接入时按照一定的接口标准就可以

### I/O设备和主机信息传送的控制方式

#### 程序查询方式

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417144320348.png" alt="image-20220417144320348" style="zoom:67%;" />

CPU不停读I/O状态寄存器的值，所以在I/O外部设备准备数据时，CPU不能空下来，这是这里串行的含义，两者不能同时开展

为什么叫程序查询方式，CPU一旦启动I/O，就停止当前程序的执行（比如一个程序有一条命令读取I/O，就停止当前程序），在当前程序中插入一段程序，来执行上面这个流程图

这不是中断，因为这个流程的程序部分是写在原来的固有程序里面的

#### 程序中断方式

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417145401624.png" alt="image-20220417145401624" style="zoom:67%;" />

CPU在I/O设备准备数据时可以做自己的事，所以是部分并行，但没有完全解放CPU，并且中断时保存上下文也要花费时间和空间，在中断处理程序中，I/O设备依然要等到CPU的指令来进行下一步操作，所以这时候是串行的

##### 程序中断方式流程

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417145923280.png" alt="image-20220417145923280" style="zoom:67%;" />

只有一开始CPU向I/O发读指令的时候两者才是并行的，后面CPU在取数的时候I/O依然要等待



### DMA方式

前面两者都需要CPU的参与，DMA可以将CPU从数据输入输出中解放出来，实现I/O设备和内存之间的直接传输

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417153153702.png" alt="image-20220417153153702" style="zoom:67%;" />

CPU发出启动I/O的指令后开始干自己的事，I/O在DMA控制器的控制下准备数据，当数据准备好时，向DMA控制器发出DMA请求，DMA再向CPU发送总线请求来占用总线，占用一个存取周期，利用这一个存取周期完成外部设备和内存之间的数据交换，这一个存取周期内CPU不可以使用总线和访问内存。有些时候指令时多条放到CPU中的，所以在这个存取周期中也不用这条总线，也不用访问内存，所以也可以并行。存取周期结束后总线的控制权还给CPU。

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417155014163.png" alt="image-20220417155014163" style="zoom:67%;" />

可以看出DMA占用系统总线时CPU就不能用了

关于同步异步，可以理解为有一系列规定要做的动作，但是什么时候做不确定，同步就是给时钟告诉你时钟开始就做一步，异步就是通过信号告诉你可以做，所以程序中断方式中，中断请求一发，中断处理程序执行，之后的程序有很多传输指令，就要考虑同步异步，同理程序查询方式也是如此，一旦状态变更，可以取数了，就可以考虑各个器件之间的同步异步

#### 三种方式的比较

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417160028815.png" alt="image-20220417160028815" style="zoom:67%;" />

DMA方式，CPU还可以继续执行指令，只是不能使用系统总线和访问内存，所以不用像中断程序那样保存上下文

#### 通道方式

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417161011292.png" alt="image-20220417161011292" style="zoom:67%;" />

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417161209926.png" alt="image-20220417161209926" style="zoom:67%;" />

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417161256170.png" alt="image-20220417161256170" style="zoom:67%;" />

通道就是一个简化版的CPU

### I/O设备

#### 概述

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417162739346.png" alt="image-20220417162739346" style="zoom:67%;" />

第三种也包括网卡

#### 输入设备

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417163139149.png" alt="image-20220417163139149" style="zoom:67%;" />

#### 输出设备	

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417163642080.png" alt="image-20220417163642080" style="zoom:67%;" />

#### 其他

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220417164851925.png" alt="image-20220417164851925" style="zoom:67%;" />

#### 多媒体技术



### I/O接口

#### 概述

为什么要设置接口

1.外部设备通过总线与主机连接，所以要实现设备的选择

2.实现数据缓冲达到速度匹配

3.实现数据串-并格式转换 主机和I/O接口之间并行传输，I/O接口外部和外部设备之间串行传输，所以要对数据进行拆分和组装

4.实现电平转换，主机和I/O设备的工作电平不一致

5.通过接口传送控制命令

6.反映设备的状态，忙，就绪，中断请求

#### 接口的功能和组成

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418191900114.png" alt="image-20220418191900114" style="zoom:67%;" />

完成触发器D：设备是否准备好，数据是否准备好，D=1，准备工作已经完成，D=0，准备工作尚未完成

工作触发器B：B=1，外部设备忙，B=0，外部设备完成工作，闲

中断请求触发器INTR：中断方式需要用到，接口有中断请求触发器，但又中断请求的情况下也要考虑中断请求的重要性，需要屏蔽触发器

屏蔽触发器MASK：置1，即使有中断也不能向主机发送中断请求



##### 总线连接方式的I/O接口电路

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418190536676.png" alt="image-20220418190536676" style="zoom:67%;" />

设备选择线传设备号和端口号，就是设备和端口地址，单向，传到每个I/O接口中进行比较，相同即选中#

状态线也是单向，传给CPU表达I/O接口的状态

#### I/O接口的基本组成部分

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418191232036.png" alt="image-20220418191232036" style="zoom:67%;" />

#### 接口类型

##### 按照数据传送的方式

并行接口

串行接口

##### 按照功能选择的灵活性分类

可编程接口（可以通过软件的方式设置功能与工作方式）

不可编程接口（不可以通过软件方式，可以通过硬件？硬连？设置功能与工作方式）

##### 按照通用性分类

通用接口

专用接口（只能用于主机对某种外部设备）

##### 按照数据传送的控制方式

程序查询方式不需要接口进行控制（但是有接口）

中断接口（程序中断方式）

DMA方式（DMA方式）



### 程序查询方式

#### 程序查询方式的流程

##### 查询流程

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418192555124.png" alt="image-20220418192555124" style="zoom:67%;" />

检查状态标记：测试指令，准备就绪：跳转指令，交换数据：传送指令或访存指令，多个设备时需要按照优先级进行查询

##### 程序流程

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418193133874.png" alt="image-20220418193133874" style="zoom:67%;" />

计数值是保存在CPU的寄存器或者内存中，每次只传送一个字，这个流程需要程序员自己写程序嵌入到应用程序中去

#### 程序查询方式的接口电路

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418194410176.png" alt="image-20220418194410176" style="zoom:67%;" />

读命令启动，接口比较地址线和自己的地址或者端口地址，只有符合并且有启动命令才会置两个状态标记的值，D置为0，表示还没准备好，B置为1，表示设备忙，同时这个信号发送到设备启动设备，设备准备数据完成并放到DBR后，4信号会重新置D和B的状态位，将D置为1，B置为0，在此之前，CPU一直在查询D的状态，一旦D置为1，就取走数据。



### 程序中断方式

#### 中断的概念

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418195243196.png" alt="image-20220418195243196" style="zoom:67%;" />

#### I/O中断的产生

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418195455457.png" alt="image-20220418195455457" style="zoom:67%;" />

启动打印机的指令在原先的指令里面，CPU和打印机是部分并行工作的

#### 程序中断方式的接口电路

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418195751882.png" alt="image-20220418195751882" style="zoom: 67%;" />

除了程序查询方式中寄存器和状态标志，还需要中断请求触发器和中断屏蔽触发器

##### 中断请求触发器和中断屏蔽触发器

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418200148220.png" alt="image-20220418200148220" style="zoom:67%;" />

MASK输出的是Q非，所以当MASK为0，即不屏蔽中断，和D标志位和在一起才有效

##### 中断排队器

多个设备发送中断，需要排队

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418202208988.png" alt="image-20220418202208988" style="zoom:67%;" />

INTP‘指的是向上输出的那条信号，如果INTR2为1，那么1到2都会输出高电平，2之后的都是低电平，最左边接地为0，取反默认为1，所以中间有中断信号时，一般是1111000的形式，按理来说是最右边的1为真实的中断信号，这里做了与非再非的操作，这样只有真正的中断信号才会输出高电平

##### 中断向量地址形成部件

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418212248635.png" alt="image-20220418212248635" style="zoom:67%;" />

排队器输出只有一个1，设备编码器根据中断向量具体的位置编码出向量地址

### I/O中断处理过程

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418212428551.png" alt="image-20220418212428551" style="zoom:67%;" />

EINT就是汇编中标志寄存器中的IF

#### 图示

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418212455613.png" alt="image-20220418212455613" style="zoom:67%;" />

中断查询信号感觉像是与是时钟有关，CPU在每次指令结束时发送中断查询信号，如果INTR的D口为1，中断查询信号会触发INTR，1就能传送至输出端（自己猜想，可能和寄存器触发刷新类似）

#### 中断服务程序的流程

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418212645725.png" alt="image-20220418212645725" style="zoom:67%;" />

程序断点的保护有些不能用指令进行保存，所以需要硬件来完成，就被称为中断隐指令（因为不是真正的指令）

### 单重中断和多重中断

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418212805291.png" alt="image-20220418212805291" style="zoom:67%;" />

单重中断不论新的中断优先级有多高

#### 单重中单和多重中断的服务程序流程

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418213254021.png" alt="image-20220418213254021" style="zoom:67%;" />

中断隐指令包含断点地址入栈以及一系列其他的操作，这些都是通过硬件完成的，在中断服务程序中才开始执行保存寄存器的指令。多重中断保护现场就是指保护寄存器，为什么保护寄存器要在开中断前，因为上一个程序的寄存器信息还没保存好，保存好之后再开中断。

实际上恢复现场前也要关中断，结束后再开中断、

#### 主程序和服务程序抢占CPU示意图

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418213856016.png" alt="image-20220418213856016" style="zoom:67%;" />

<u>我还是不懂CPU的中断查询信号的具体作用</u>

### DMA方式

#### DMA方式的特点

##### DMA和程序中断两种方式的数据通路

不像程序中断和程序查询方式依赖CPU进行数据传输

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418214648976.png" alt="image-20220418214648976" style="zoom:67%;" />

ACC就是作为数据传输的中转，导致CPU必须中断当前的程序来完成这个转运，所以只有中断时要用到CPU

DMA将CPU进一步从中断中解放出来

#### DMA与主存交换数据的三种方式

##### 停止CPU访问主存

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418220225614.png" alt="image-20220418220225614" style="zoom:67%;" />

外部设备将一块数据传输到主存时，CPU一旦读到这条指令，就启动外部设备，并且放弃总线和主存的控制访问

问题在于CPU在很长的一段时间内不能使用总线和主存，虽然只要Cache中和指令缓冲器中有指令就可以不用访存，但是时间间隔比较长，没有提高CPU对主存的利用率

问题在于要传输一块数据，但是每次都是一个字一个字传输，传完一个字要等待外部设备再次准备，在这短时间内DMA没有使用总线和主存，但是CPU也不能使用，浪费了很多时间

<u>什么是主存周期？</u>

##### 周期挪用

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418215317333.png" alt="image-20220418215317333" style="zoom:67%;" />

和上面一样的问题，在窃取的周期内CPU并不能访问主存，但是只要Cache中或指令缓冲器中指令没执行完毕，就可以不访存，周期挪用将这个时间间隔减少了

##### DMA和CPU交替访问内存

实用性不强

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220418215435376.png" alt="image-20220418215435376" style="zoom:67%;" />

用时序来控制总线的使用权

### DMA接口的功能和组成 

#### DMA接口功能

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220419191400786.png" alt="image-20220419191400786" style="zoom:67%;" />

#### DMA接口组成

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220419193258941.png" alt="image-20220419193258941" style="zoom:67%;" />

进行I/O时，需要确定操作的是内存的哪个地址，因此需要AR寄存器保存内存地址，AR通过地址线将访问的内存传送给主存（这时候DMA接口接管了总线和主存）

DAR保存该外部设备的地址，这样地址选择的时候可以检验是否选择了这个外部设备

外部设备要想进行DMA传输，需要向DMA发送DREQ信号，DMA响应返回DACK信号，那么DMA控制器通过总线向CPU发送HRQ信号，CPU返回HLDA信号，让出总线和主存的控制权

WC的值为0时，会向中断机构发送溢出信号，将中断触发器的值置为1，中断机构通过总线向CPU发送中断请求，来处理传输完成后的一些事。

#### 多路型DMA接口的工作原理



DMA的工作过程

#### DMA的传输过程

预处理、数据传输、后处理

##### 预处理

CPU读到I/O指令后需要做的一系列工作

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220419195108080.png" alt="image-20220419195108080" style="zoom:67%;" />

##### 传送过程示意图

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220419195410109.png" alt="image-20220419195410109" style="zoom:67%;" />

允许传送为否的情况可能是CPU这是后在使用总线访存，所以会继续发DMA请求

#### 数据输入为例（以主机为主，输入就是外部设备到内存中）

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220419200235363.png" alt="image-20220419200235363" style="zoom:67%;" />

最开始CPU通过数据线设置其中寄存器的值，并且向设备发送启动信号

设备将数据准备好放到BR中后，发出DREQ信号，DMA控制逻辑发请求，CPU回请求，AR此时发送地址线，让其有效，然后DMA控制逻辑发送DACK给设备，预示即将开始传送。DMA此时向主存发送控制信号，并将BR的数据发送给主存，完成AR的值和WC的值需要改变

#### 数据输出为例

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220419201116632.png" alt="image-20220419201116632" style="zoom:67%;" />

设备在BR为空的时候才发信号给DMA控制逻辑，然后一些响应回来之后要开始传输，将AR的地址线置有效，DMA控制逻辑将DACK返给设备告诉它传输即将开始，然后DMA传读控制信号，内存传送数据到BR

输入输出最花时间的部分就是BR到设备和设备到BR，所以数据到BR（内存的取周期结束）之后DMA让出总线，CPU继续执行，此时数据正从BR到设备，等到BR空，设备就又可以发送DREQ信号。

#### 后处理

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220419202007420.png" alt="image-20220419202007420" style="zoom:67%;" />

就是WC的值为0，一块数据完成传输后发出中断请求，CPU之后要做的一系列事，由中断服务程序完成。

### DMA接口与系统连接方式

#### 具有公共请求线的DMA请求

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220419202416857.png" alt="image-20220419202416857" style="zoom:67%;" />

进行DMA响应的时候，CPU对DMA接口也有个优先级排序

#### 独立的DMA请求

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220419202906551.png" alt="image-20220419202906551" style="zoom:67%;" />

优先级的排序在CPU中进行

### DMA方式与程序中断方式的比较

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220419204723329.png" alt="image-20220419204723329" style="zoom:67%;" />

存取周期结束指的是CPU对主存的存取周期结束，就可以相应DMA让出总线和主存的控制权，因为CPU访存的时候DMA智能等待

### DMA接口的类型

#### 选择型

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220419210234168.png" alt="image-20220419210234168" style="zoom:67%;" />

可以理解为同一时刻只有一个设备能用，并且在这个设备用完之前其他设备不能用（整个过程，包括数据准备过程等）

#### 多路型

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220419210506333.png" alt="image-20220419210506333" style="zoom:67%;" />

CPU读到一条I/O指令，启动某一个外部设备，开始准备数据，自己执行后面的指令，由读到一条I/O指令，如果是不同的外部设备，又可以启动，并且该外部设备开始准备数据，也就是所有的外部设备连接的子通道同一时间都可以准备数据，只有开始存取时只能允许一个设备工作

#### 多路型DMA接口的工作原理

![image-20220419212202615](C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220419212202615.png)

从BR到存储器和存储器到BR所花的时间只有5us

### 无符号数和有符号数

#### 无符号数

保存在寄存器或者存储器中，直接可以根据位数判断范围

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220419214222438.png" alt="image-20220419214222438" style="zoom:67%;" />

负数求补码

1.原码符号位不变，其余位取反加1

2.正数的原码取反加1



补码求负数

各位取反加1，正数的原码，将符号位改变

符号位不变，其余各位取反加1



综上所述，符号位不变，其余位取反加1可以实现负数原码和负数补码之间的转换

负数补码取反加1就可以知道绝对值

负数取绝对值原码再取反加1就可以得补码





### 机器指令

#### 指令格式

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220420193140705.png" alt="image-20220420193140705" style="zoom:67%;" />

操作码还可能反映对什么数据做操作，比如定点数的加法，浮点数的加法就要用不同的指令

长度可变的操作码，比如x86就是

#### 操作码

##### 扩展操作码技术

为了让操作码长度可变

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220420193956596.png" alt="image-20220420193956596" style="zoom:67%;" />

三地址指令1111作为扩展标志位，出现1111说明操作码最少8位，1111 1111作为扩展标志码，依次类推

这样可以防止短操作码是长操作码的前缀，因为如果短操作码是长操作码的前缀，计算机识别不出那部分是操作码

思考：给固定字长，如何给不同位数的操作码赋指令

使用频率高的操作码位数少，使用频率低的操作码位数多，指令译码需要时间，取地址差不多，所以高频指令操作码位数低可以加快译码速度

上图中的长度，如何编码，可以使操作码总共有31条指令，1110和1111作为扩展标志位，4-8在1111的时候留1111作为标志位

#### 地址码

##### 四地址

![image-20220420200315697](C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220420200315697.png)

访存4次，最后的A4是下一条指令的访存

可以理解成没有PC所以每一次取一条指令都要有吓一跳指令的地址

##### 三地址

如何增大寻址范围，将A4取消，用PC代替

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220420200431454.png" alt="image-20220420200431454" style="zoom:67%;" />

还是访存4次，如何再扩大访存范围，就用A1或者A2代替存储的位置，得到二地址

##### 二地址

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220420200639297.png" alt="image-20220420200639297" style="zoom:67%;" />

从三地址转到二地址，是少了一个存放地址，也可以把它放在默认的寄存器中，这样还可以减少访存次数

如何再扩大访存范围，默认一个操作数在寄存器中，只要给出另一个操作数的内存地址，结果放在寄存器中就可以，这个寄存器是ACC，就形成1地址

##### 一地址

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220420200946744.png" alt="image-20220420200946744" style="zoom:67%;" />

访存范围大大提高

##### 零地址

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220420201216831.png" alt="image-20220420201216831" style="zoom:67%;" />

无地址码怎么做到，比如默认操作数在ACC中，对数据取反、清零等操作就不需要地址

或者是栈计算机，add指令就表示栈顶的两个数据相加，再把结果放到栈顶

#### 指令字长

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220420201431847.png" alt="image-20220420201431847" style="zoom:67%;" />

#### 小结

#### <img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220420202148776.png" alt="image-20220420202148776" style="zoom:67%;" />

可缩短指令字长是指如果地址码的位数不发生改变，在四指令变三指令变二指令的过程中，指令字长就会减少

寄存器的数量比较少，比如有16个寄存器，只需要4位就可以编号，当三地址变二地址变一地址时，指令的字长就可以减少，所有的取数操作都是访问寄存器，不用访问内存



### 操作数类型和操作种类

#### 操作数类型

在内存或者寄存器中

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220420202808516.png" alt="image-20220420202808516" style="zoom:67%;" />

表示绝对地址的时候就是无符号整数，表示相对地址的时候就是有符号数

#### 数据在存储器中的存放方式

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220420202904489.png" alt="image-20220420202904489" style="zoom:67%;" />

低地址放高位 大端

低地址放低位 小端

这里的数占4个字节

这里都是以存储字

##### 从任意位置开始访问

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220420204155538.png" alt="image-20220420204155538" style="zoom:67%;" />

这里的字指的是机器字长，这样存储单元就是双字，读的时候都是以存储单元来读

除了字节以外的数据，都可能横跨两个存储字长，但节省空间

就算地址在存储字长的中间，给出一个这么的地址，也不会从这个地址开始取，是从所在存储字长的开始取，如果没取完，再取下个存储字长，以为存储字长代表着机器存取的基本单元

##### 从一个存储字的起始地址开始访问

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220420204350102.png" alt="image-20220420204350102" style="zoom:67%;" />

能保证读一次就读完数据 

##### 边界对准方式

![image-20220420204809961](C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220420204809961.png)

比如从xx30开始，本来这一行不能再放单字，需要重新开一行，但是现在可以放在里面，每次读一个存储字，都能保证读到所需要的数据

如果访问数据最小长度-字节还是大于存储字的长度，边界对准就不需要，就像汇编语言中用一个字节做存储字

### 操作类型

指令代表某种操作，可以简单理解为操作码部分

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220420205049522.png" alt="image-20220420205049522" style="zoom:67%;" />

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220420205259455.png" alt="image-20220420205259455" style="zoom:67%;" />

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220420205400437.png" alt="image-20220420205400437" style="zoom:67%;" />

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220420205639267.png" alt="image-20220420205639267" style="zoom:67%;" />

操作码非法，操作数返回越界，除数为0，不是指令集当中的指令，就是中断

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220420205809699.png" alt="image-20220420205809699" style="zoom:67%;" />

如果使用内存的一部作为外部设备的地址，就不需要专门的输入输出指令，直接使用访问寄存器的指令

如果单独编址，则有专门的I/O的指令



### 寻址方式

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220420210239306.png" alt="image-20220420210239306" style="zoom:67%;" />

#### 指令寻址

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220420211001250.png" alt="image-20220420211001250" style="zoom:67%;" />

#### 数据寻址

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220420211649360.png" alt="image-20220420211649360" style="zoom:67%;" />

形式地址指的就是指令中出现的地址，有效地址是真实的地址

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220420211603900.png" alt="image-20220420211603900" style="zoom:67%;" />

A如果是立即数，就说明操作数已经在CPU中

#### 直接寻址

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220420211939879.png" alt="image-20220420211939879" style="zoom:67%;" />

#### 隐含寻址

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220420212131381.png" alt="image-20220420212131381" style="zoom:67%;" />

指的是add就告诉我们一个操作数的地址在ACC中，寻址特征决定另一个操作数的寻址方式，比如另一个操作数的寻址特征是直接寻址，就可以去内存中读

#### 间接寻址

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220420212510646.png" alt="image-20220420212510646" style="zoom:67%;" />

直接寻址是A的地址里面就是操作数，那么简介寻址就是A的地址里面的数据是操作数的地址，通过该地址才能找到操作数

多次间址就会用一个标志位表示该地址是否是操作数的地址，如果为1，继续找，只有为0，才说明这个地址是操作数的地址

#### 寄存器寻址

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220420213603850.png" alt="image-20220420213603850" style="zoom:67%;" />

也被称为寄存器直接寻址，即表示的地址就是有效地址，就是寄存器的编号

#### 寄存器间接寻址

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220420213753030.png" alt="image-20220420213753030" style="zoom:67%;" />

操作数的地址放在寄存器中，操作数放在内存中

#### 基址寻址

##### 采用专用寄存器作基址寄存器

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220420214029315.png" alt="image-20220420214029315" style="zoom:67%;" />

BR的内容一般不能由用户改变，BR是默认设定的，所以不用给出BR的编号，A实际上就相当于一个偏移量 

##### 采用通用寄存器作基址寄存器

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220420214248993.png" alt="image-20220420214248993" style="zoom:67%;" />

在指令中指明通用寄存器编号，但是在执行过程中还是不能改变基址寄存器的内容



#### 变址寻址

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220420214605118.png" alt="image-20220420214605118" style="zoom:67%;" />

和基址寻址十分相似，同样的变址寄存器可以默认指定也可以用户指定，但是不同的是基址寻址不能改变内容，变址寻址用户可以改变内容，便于处理数组问题，比如A是数组的首地址，IX代表数组索引

##### 变址寻址的例子

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220420215243694.png" alt="image-20220420215243694" style="zoom:67%;" />

为什么N也要表明是立即数，因为CPU不知道这个代表地址还是数

#### 相对寻址

相对PC， 形式地址相当于偏移量

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220420215431646.png" alt="image-20220420215431646" style="zoom:67%;" />

##### 相对寻址举例

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220420215610156.png" alt="image-20220420215610156" style="zoom:67%;" />

##### 按字节寻址的相对寻址举例

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220420215759459.png" alt="image-20220420215759459" style="zoom:67%;" />

这个符合一般计算机的规则，指令加载到指令缓冲区中，还未执行，此时PC+1（这里的1是2个字节，因为指令长2个字节），所以执行指令的时候偏移量应该为6，上一个相对寻址举例没考虑还未执行时PC就要增加的因素

##### 堆栈寻址

1.堆栈的特点

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421093055958.png" alt="image-20220421093055958" style="zoom:67%;" />

堆栈计算机一般采用硬堆栈的方法，多个寄存器做栈顶，add指令过后将结果存在栈顶，也是寄存器，只不过栈底在内部

8086用的就是软堆栈，内存中的一部分空间做堆栈

2.堆栈寻址举例

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421093529734.png" alt="image-20220421093529734" style="zoom:67%;" />

3.SP的修改与主存编址方法有关

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421094319997.png" alt="image-20220421094319997" style="zoom:67%;" />

字编址，就是一个存储字是一个地址，0,1,2,3这样上去，字节编址，比如32位的存储字，则一个存储到下一个存储字的地址变化是4，存储字长和按什么编址完全没有关系

这里我感觉它数据存放方式就是用了从一个存储器的开始位置存放，比如一个1字节的数据，32位的存储字按理来说还有3个字节，可以放一个半字，但是直接-4了，说明剩下不要了，下一个数据再放、

### 指令格式举例

#### 设计指令格式时应考虑的各种因素

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421095215510.png" alt="image-20220421095215510" style="zoom:67%;" />

#### IBM360

IBM360指定的操作码长度都是8位

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421095536561.png" alt="image-20220421095536561" style="zoom:67%;" />

RR格式，比如将两个寄存器的值相加，结果存放在其中一个寄存器中

RX格式 不知道类似啥操作，反正操作对象时内存和寄存器，内存地址是X+B+D，R1是寄存器

RS格式，将R1到Rn的寄存器的值全部传送到B+D的地址

SI格式，不知道类似啥操作，反正操作对象是立即数和内存，内存地址是B+D，立即数是I

SS格式，两个内存块的传送，将B1+D1长为L的内存块转存到B2+D2的内存块

#### Intel8086

##### 指令字长

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421100313021.png" alt="image-20220421100313021" style="zoom:67%;" />

##### 地址格式

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421100304009.png" alt="image-20220421100304009" style="zoom:67%;" />

### 习题

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421105219561.png" alt="image-20220421105219561" style="zoom:67%;" />

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421105413291.png" alt="image-20220421105413291" style="zoom:67%;" />

直接寻址是20位，这里的范围是字（她说寻址都是以字为单位？没有以字节为单位的）

间接寻址地址线是32位，范围是2的32次

这里的I指的是寻址方式，只有2种，所以占1位

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421145550854.png" alt="image-20220421145550854" style="zoom:67%;" />

（1）中的问题实行的是寄存器到内存的传输，（2）在（1）的基础上，只不过内存的地址用基址寄存器的方式访问，这个基址寄存器是用通用寄存器，所以需要我们指定，位数为5位，本来间接标志需要2位，因为总共有3种寻址方式，但是把一个寄存器放在间接标志后面CPU就可以明白这是基址寻址，所以只需要1位就行。寻址范围是通用寄存器里面的内容+A是操作数的地址，32位+15位总共还是32位，所以寻址范围是2的32次。

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421150101447.png" alt="image-20220421150101447" style="zoom:67%;" />

无论是按字寻址还是按字节寻址，感觉找的时候还是按照存储字为单位



### RISC

#### RISC 的产生和发展

早期的计算机一定是复杂的，逐渐发展成简单的

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421151117875.png" alt="image-20220421151117875" style="zoom: 67%;" />

 指令都是通过硬件实现的，但是如果要考虑到80%的复杂指令，就要设计硬件，导致硬件变得很复杂，另一方面会拖慢20%的简单指令的执行时间

所以考虑只保留20%简单指令的硬件设计，剩下80%的复杂指令都用20%简单指令组合而成，这就是RISC技术的思想

#### RISC的主要特征

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421151651862.png" alt="image-20220421151651862" style="zoom:67%;" />

一般的数据传输都在寄存器中完成，只有两条指令牵扯到访存

组合逻辑就是硬件方式

#### CISC的主要特征

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421152007861.png" alt="image-20220421152007861" style="zoom:67%;" />

微程序由微指令组成，微指令就是指令中的一个基本的步骤，微指令组成的微程序保存在控制存储器当中

可以看出汇编的8086用的就是CISC，因为有很多访存手段

#### RISC和CISC的比较

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421152405353.png" alt="image-20220421152405353" style="zoom:67%;" />

不易兼容是因为RISC指令设计得比较紧凑

### 

### CPU的结构

#### CPU的功能

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421152902702.png" alt="image-20220421152902702" style="zoom:67%;" />

#### CPU结构框图

##### CPU与系统总线

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421153608181.png" alt="image-20220421153608181" style="zoom:67%;" />

注意控制总线和数据总线是双向的，地址总线是单向的

CU需要译码，并且在给定的时刻给出操作命令，所以CU里面有时序电路

### CPU的寄存器

#### 用户可见寄存器（按可见与不可见分）

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421154307331.png" alt="image-20220421154307331" style="zoom:67%;" />

#### 控制和状态寄存器

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421155823274.png" alt="image-20220421155823274" style="zoom:67%;" />

PSW里面保存的就是程序状态字，程序状态字是很多个程序表示程序状态的寄存器拼在一起组成的寄存器

### 控制单元CU和中断系统

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421160304804.png" alt="image-20220421160304804" style="zoom:67%;" />



### 指令周期

#### 指令周期的基本概念

##### 指令周期

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421160618480.png" alt="image-20220421160618480" style="zoom:67%;" />

将指令周期分为取指周期和执行周期只是我们的分法，实际上不同的CPU和指令集可能有不同的分法

##### 每条指令的指令周期不同

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421160857000.png" alt="image-20220421160857000" style="zoom:67%;" />

为什么add方法取指周期和执行周期差不多，因为取指和执行最主要的时间部分是访问内存，加法所占的时间比重很小

MUL指令的乘法操作所占的时间就比较长

##### 具有间接寻址的指令周期

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421161425907.png" alt="image-20220421161425907" style="zoom:67%;" />

间址周期指的是找到操作数的地址，因为间址寻址中间可能有很多步

执行周期是指把操作数取出来，执行一系列操作，再放回到内存或者相应位置

##### 带有中断周期的指令周期

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421161635235.png" alt="image-20220421161635235" style="zoom: 67%;" />

中短周期主要做保存断点，形成中断服务程序的入口地址，硬件关中断等操作

#### 指令周期流程

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421161945738.png" alt="image-20220421161945738" style="zoom:67%;" />

#### CPU工作周期的性质

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421162224031.png" alt="image-20220421162224031" style="zoom:67%;" />

虽然都是对内存做存取操作，但是取回来的数据后续要给CPU或者给寄存器，所以是不同的操作，CPU需要明白现在自己在哪个周期才能知道自己要做什么，所以要用触发器来表明自己所处的状态



### 指令周期的数据流

#### 取指周期数据流

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421162600626.png" alt="image-20220421162600626" style="zoom:67%;" />

#### 间址周期数据流

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421162839535.png" alt="image-20220421162839535" style="zoom:67%;" />

这一步得到了操作数的地址

在指令开始执行时，IR当中有指令，MDR当中也有指令，只要从中取出地址即可，这里选用从MDR中取地址

则给存储器，存储器返回数据，这个数据实际上是操作数所在内存单元的地址，存储在MDR中

#### 执行周期数据流

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421170318673.png" alt="image-20220421170318673" style="zoom:67%;" />

#### 中断周期数据流

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421170341605.png" alt="image-20220421170341605" style="zoom:67%;" />

第一步，保存断点，第二步，生成中断服务程序的地址

保存断点需要知道保存到内存的哪里，这个地址是CU给出的，然后断点就是下一条指令的地址，将PC中的值写到存储器中

生成中断服务程序的地址目前只要知道是CU直接给出就行，CU将中断服务程序的地址给PC

### 指令流水

#### 如何提高机器速度

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421190259814.png" alt="image-20220421190259814" style="zoom:67%;" />

#### 系统的并行性

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421190458732.png" alt="image-20220421190458732" style="zoom:67%;" />

指令之间就是微指令的并行

#### 指令流水的原理

##### 指令的串行执行

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421190847776.png" alt="image-20220421190847776" style="zoom:67%;" />

把执行指令的看做是一个部件，那么取指令执行指令，取指令执行指令，如果把取指令和执行指令分开形成两个部件，那么取指令和执行指令如果按照串行的方式，总有一个部件空闲，所以可以改进出二级流水

##### 指令的二级流水

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421190902678.png" alt="image-20220421190902678" style="zoom:67%;" />

##### 影响指令流水效率加倍的因素

 <img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421191449685.png" alt="image-20220421191449685" style="zoom:67%;" />

比如执行时间是取指时间的两倍，取指结束，开始执行，此时可以取下一条指令，执行一半的时间取完下一条，剩下一半的时间再取下一条，因为不能执行，所以要放在指令部件缓冲区内，等执行指令部件空闲时就能立刻执行

比如je 跳转，必须等上一条指令执行完毕才能确定下条指令的地址，所以破坏了流水线



#### 指令的六级流水

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421191938372.png" alt="image-20220421191938372" style="zoom:67%;" />

六个步骤为取指、指令译码、形成操作数的地址、取操作数、执行、结果写回

以上指令基于没有冲突，没有转移指令



### 影响指令流水线的因素

#### 结构相关

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421192420654.png" alt="image-20220421192420654" style="zoom:67%;" />

第一条指令4时间段取操作数，第四条指令4时间段取指令，同时访问内部可能会产生冲突

解决方法就是将第4条指令的取值往后延，也被称为加入气泡

指令预取技术是指提前取大量的指令到指令缓冲器中，这样流水线中可以节省很多取址的步骤



#### 数据相关

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421193637781.png" alt="image-20220421193637781" style="zoom:67%;" />

写后读，先写后读，也就是两条指令，一条指令先写，另一条指令才能去读，如六级指令流水线中，指令1是往某个寄存器中写入值，指令2是读出写入的值，指令2在时刻5就要把这个数读出来，但是指令1要到时刻6才能把结果写回去

所谓后推法，就是读这个数的步骤往后推，直到它写回去

所谓旁路技术，就是比如指令3第4条微指令也就是时间6要读之前寄存器的值，但指令1刚开始写回，实际上这时候的运算结果已将在ALU的输出端，可以直接把这个结果给指令3执行时候的操作数输入



#### 控制相关

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421194330510.png" alt="image-20220421194330510" style="zoom:67%;" />

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421194517736.png" alt="image-20220421194517736" style="zoom:67%;" />

指令2在时间6已经执行完毕，指令3是转移指令，只有运行到时间7的执行阶段结束才知道是否需要转移，所以到时间7之前包括时间7都会有新的指令流水线进入，如果时间7执行完发现要转移到指令15，那么之前的取指都浪费了，这个往后推的时间就是转移损失



### 流水线性能

#### 吞吐率

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421195046169.png" alt="image-20220421195046169" style="zoom:67%;" />

最大吞吐率就是一个理论值，没有资源冲突，没有数据相关，没有控制相关，也有一种说法是流水线达到稳定流动状态后所获得的吞吐率

实际吞吐率就是实际一段时间完后才能的指令条数进行计算，最好的方法就是实际计算，实际吞吐率实际上就是完成n条指令的实际吞吐率

#### 加速比

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421200838968.png" alt="image-20220421200838968" style="zoom:67%;" />

​	

n条指令没有采用流水线的时间除以采用流水线技术的时间，这里考虑的是比较理想的情况，没有各种冲突，如果有冲突，那么就实际时间相除



#### 效率

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421201958187.png" alt="image-20220421201958187" style="zoom:67%;" />

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421202016693.png" alt="image-20220421202016693" style="zoom:67%;" />

方格中相同的数代表同一条指令，空间代表指令执行的阶段，流水线实际执行的时空区就是一行有n*△t个，总共有m行，所以是mn△t

### 流水线的多发技术

#### 超标量技术

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421202538695.png" alt="image-20220421202538695" style="zoom:67%;" />

实际上就是增加了多个流水线，这多个流水线运行的指令应该要并行，没有冲突

可以不用调整（这里是不能，但看视频里说的意思是不用？实际上指的是做不到在执行的时候调整指令的执行顺序，只能在编译的时候安排

）指令的顺序，编译阶段会自动地把可执行的指令搭配起来

#### 超流水线技术

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421203816866.png" alt="image-20220421203816866" style="zoom:67%;" />

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421204920417.png" alt="image-20220421204920417" style="zoom:67%;" />

最大吞吐率变成了原来的三倍（提高了主频？）

<u>这里还是不太懂</u><u>时间换空间和空间换时间 流水线越长 指令花费时间反而越多</u>



#### 超长指令字技术

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421205513093.png" alt="image-20220421205513093" style="zoom:67%;" />

多条指令合并成1条，取指一个时间周期，译码一个时间周期，然后执行中具体的操作有取数，存数，顶点运算等操作，由控制单元控制不同部件运行

可以理解成本来很多操作分布到各条指令中，这样流水线就要推很多次，现在是把多条指令合在一起，取指和译码只要一次就能完成，就能节省时间

#### 流水线结构

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421210757920.png" alt="image-20220421210757920" style="zoom:67%;" />

锁存器保存前面流水段的操作结果，同时为下一段提供操作数据和操作信号 



#### 运算时钟周期

![image-20220421211144167](C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421211144167.png)

假设每段的执行时间是一个时钟周期，如果时间不等，那么要根据最长的执行时间确定时钟周期，有点时间就会浪费，比如取指时间短，执行时间很长，为了保证

同步（如果以较短的时间作为时钟周期，那么在执行的时候一个时钟过去了锁存器还没得到结果这个部件就要给另一条指令用了），就要以最长的执行时间为时钟周期，那么取指阶段就会有一段时间空闲



### 中断系统

#### 概述

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421211859915.png" alt="image-20220421211859915" style="zoom:67%;" />

#### 中断系统需要解决的问题

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421212212434.png" alt="image-20220421212212434" style="zoom:67%;" />

#### 中断请求标记和中断判优逻辑

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421212435651.png" alt="image-20220421212435651" style="zoom:67%;" />

分散在各个中断源的接口电路中，可以逻辑上组成中断请求标记寄存器



#### 中断判优逻辑

##### 硬件实现

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421212935328.png" alt="image-20220421212935328" style="zoom:67%;" />

优先级高的一旦有中断信号，那么后面的输出都为0

优先级高的如果没有中断信号，能确保后面有中断信号的输出结果为1

##### 软件方式（程序查询）

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421213201139.png" alt="image-20220421213201139" style="zoom:67%;" />

比如可以看中断请求标记寄存器的各个位，判断优先级



### 中断服务程序的入口地址的寻找

#### 硬件向量法

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421213459436.png" alt="image-20220421213459436" style="zoom:67%;" />

排队器的输出时只有1位为1，代表最高优先级的中断，根据向量地址形成部件的硬件来得出中断向量地址

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421214239405.png" alt="image-20220421214239405" style="zoom:67%;" />

或许在有中断请求的时候，直接查询每个接口的完成触发器就知道是不是这个中断源，如果是，就直接跳转到这个的服务程序

<u>如果Mask为0又怎么办，这时候它的中断被屏蔽了，但如果优先级高，不是执行它的中断服务程序了？</u>



### 中断响应

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421215705911.png" alt="image-20220421215705911" style="zoom:67%;" />

CPU中断查询会将INTR的输出送到排队器，感觉就是一个触发作用，只有CPU查询了



#### 中断隐指令

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421220727121.png" alt="image-20220421220727121" style="zoom:67%;" />

这些操作都不是指令集中的指令，所以被称为隐指令

关中断，在单重中断中，是为了防止中断程序过程中再有中断，在多重中断中，也是为了保护现场

INT表示当前CPU正在执行某个中断，EINT表示CPU此时是否可以相应中断

![image-20220421221324046](C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421221324046.png)

<u>为什么关中断是在程序断点入栈前？</u>

<u>可以去看看R-S触发器的原理</u>

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422143417379.png" alt="image-20220422143417379" style="zoom:67%;" />

最开始的没有状态就是0信号 比如输入端为0和0，Q和Q非都没有信号，就是0状态，Q达到稳态0

11的状态也能到达稳定，但是设计的时候要求Q和Q非要相反，所以定为不稳定状态

### 保护现场和恢复现场

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422144408307.png" alt="image-20220422144408307" style="zoom:67%;" />

保存断点由硬件完成，保存寄存器由软件完成（感觉硬件完成就是没有明确指令，在某一个操作完成后，CPU自动执行硬件完成一系列操作，软件完成就是CPU自动执行的一系列操作由程序员写出来，然后CPU输入到硬件完成，比如说有个机器没设置中断判断，我们就要写程序判断哪个优先级最高，如果是硬件实现，就是设置排队器，由输出决定哪个优先级高）

关于硬件关中断和保存断点的顺序，网上也有先关中断，再保存断点，也许之前的图中那些操作并没有顺序

![image-20220421221324046](C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220421221324046.png)

网上的为

![image-20220422144701616](C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422144701616.png)

注意，这里中断服务程序中的保护现场指的就是保存寄存器的内容，将其保存到堆栈中或者内存的某个位置



#### 多重中断

##### 多重中断的概念

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422144933383.png" alt="image-20220422144933383" style="zoom:67%;" />

##### 实现多重中断的条件

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422145605698.png" alt="image-20220422145605698" style="zoom:67%;" />

##### 屏蔽技术

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422150039786.png" alt="image-20220422150039786" style="zoom:67%;" />

每个中断源对应一个屏蔽触发器，MASK为0，Q非在右边为1,Q在左边为0，Q非在右边为1输入排队器

当所有的中断触发器集成在CPU内部时，屏蔽触发器也可以集成在CPU内部，所有的MASK组合起来就是中断屏蔽字当中的1位

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422150452570.png" alt="image-20220422150452570" style="zoom:67%;" />

MASK凡是为1的，那么所有的输出就肯定是0，剩下的中断触发器在为0的中间去竞争

当多个中断同时请求，用的是排队器来判断响应哪个中断；当中断正在执行，有新的中断到来，用中断屏蔽字来判断是否需要响应

执行1中断，所有新中断被屏蔽，执行2中断，2和比2低的中断全屏蔽，只有1可以允许中断

##### 屏蔽技术可改变处理优先等级

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422152033705.png" alt="image-20220422152033705" style="zoom:67%;" />

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422151825619.png" alt="image-20220422151825619" style="zoom:67%;" />

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422152318943.png" alt="image-20220422152318943" style="zoom:67%;" />

ABCD同时请求，此时的中断屏蔽是0000，所以都进入排队器，选择A，此时中断屏蔽变为1111，BCD都不能打断，A执行结束，屏蔽字变成0000，BCD中响应B，屏蔽字变成0100，B做完保存寄存器等一系列工作，CD继续请求，CD运行请求，进入排队器，选择C，同理再进入D，D处理完后，返回去处理C，C处理完后再返回去处理B

##### 屏蔽技术的其他作用

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422152618394.png" alt="image-20220422152618394" style="zoom:67%;" />

##### 新屏蔽字的设置

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422153007892.png" alt="image-20220422153007892" style="zoom:67%;" />

在设置屏蔽字只有才能开中断，不然一开中断就去执行其他任务了



#### 多重中断的断点保护

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422153235051.png" alt="image-20220422153235051" style="zoom:67%;" />

断点入栈就不会有这样的问题，但是如果保存到固定的内存地址，就会产生覆盖的问题

0地址并不是真正的0地址，是一个固定的地址

##### 程序断点存入“0”地址的断点保护

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422155139369.png" alt="image-20220422155139369" style="zoom:67%;" />

该图表示的是一个中断服务程序

实际上就是在开中断之前将0地址中的下一条指令存到另一个位置，这里为return，然后再最后跳转到return里的地址所表示的内存单元，中途有新的中断进来，也会将0内存中的地址转存到return中，这里的return应该和上一个中断的return有联系但是不同

置屏蔽字应放在开中断前，在跳转之前恢复原来的屏蔽字	



### 控制单元

### 微操作命令分析

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422155741274.png" alt="image-20220422155741274" style="zoom:67%;" />

####  取指周期 

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422155944907.png" alt="image-20220422155944907" style="zoom:67%;" />

这里的取指周期需要完成译码的工作

#### 间址周期

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422160140099.png" alt="image-20220422160140099" style="zoom:67%;" />

最后一步操作数的地址就替换了形式地址，间址周期结束

#### 执行周期

##### 非访存指令

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422160432322.png" alt="image-20220422160432322" style="zoom:67%;" />

算术左移和循环左移的两步都是可以同时进行的，CSL中说的是ACC0->ACCn



##### 访存指令

加法指令

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422160938566.png" alt="image-20220422160938566" style="zoom:67%;" />

存数指令

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422160953367.png" alt="image-20220422160953367" style="zoom:67%;" />

取数指令

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422161158296.png" alt="image-20220422161158296" style="zoom:67%;" />

##### 转移指令

无条件转移和条件转移

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422161400705.png" alt="image-20220422161400705" style="zoom:67%;" />

#### 三类指令的指令周期

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422161609848.png" alt="image-20220422161609848" style="zoom:67%;" />

转移指令只要将IR的地址部分传到ACC中，所以不用访存，除非是间接寻址

#### 中断周期

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422163026927.png" alt="image-20220422163026927" style="zoom:67%;" />

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422163045374.png" alt="image-20220422163045374" style="zoom:67%;" />

### 控制单元的功能

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422163215947.png" alt="image-20220422163215947" style="zoom:67%;" />

#### 输入信号

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422163326400.png" alt="image-20220422163326400" style="zoom:67%;" />

#### 输出信号

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422163816463.png" alt="image-20220422163816463" style="zoom:67%;" />

#### 控制信号距离

##### 不采用CPU内部总线的方式

取指周期：

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422164328148.png" alt="image-20220422164328148" style="zoom:67%;" />

C0-C4都是CU的控制信号

间址周期：



![image-20220422164614060](C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422164614060.png)

形式地址在MDR和IR中都有，选一个就行，这里选的是MDR，然后取回来的操作数地址更新了IR中的地址部分

执行周期：

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422164951238.png" alt="image-20220422164951238" style="zoom:67%;" />

操作数的地址存放在MDR和IR中，选一个，这里选的还是MDR

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422165129585.png" alt="image-20220422165129585" style="zoom:67%;" />

##### 采用CPU内部总线方式

取址周期

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422170318829.png" alt="image-20220422170318829" style="zoom:67%;" />

所有的这些控制信号都是CU在时钟周期的控制下产生的，有一定的先后次序

间址周期：

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422170627404.png" alt="image-20220422170627404" style="zoom:67%;" />

执行周期

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422170928167.png" alt="image-20220422170928167" style="zoom:67%;" />

### 多级时序系统

#### 机器周期

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422171302957.png" alt="image-20220422171302957" style="zoom:67%;" />

最复杂指令一般认为是访存操作 

#### 时钟周期

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422171509670.png" alt="image-20220422171509670" style="zoom:67%;" />

一般机器周期同时执行和时钟周期同时执行都是并行的操作

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422171637033.png" alt="image-20220422171637033" style="zoom:67%;" />

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422171807598.png" alt="image-20220422171807598" style="zoom: 67%;" />

如果执行周期没有访问内存，可以看出它的机器周期就比价短，机器周期应该就是4阶段中的一个所花的时间，不一定要完全相等 

### 机器的速度和主频的关系

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422172117833.png" alt="image-20220422172117833" style="zoom:67%;" />

如果不考虑流水线，机器周期数与每个机器周期所含时钟周期数都相同，那么速度之比就是主频之比，但是主频相同的两台机器，一个采用流水线，一个不用，速度也不会一样

### 控制方式、

#### 同步控制方式

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422191510766.png" alt="image-20220422191510766" style="zoom:67%;" />

##### 采用定长的机器周期

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422191516689.png" alt="image-20220422191516689" style="zoom:67%;" />

这种划分方法可能会造成时间的浪费，比如取指阶段需要4个节拍，而执行阶段只需要1个节拍，那么就有3个节拍浪费了

##### 采用不定长的机器周期

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422191810999.png" alt="image-20220422191810999" style="zoom:67%;" />

##### 采用中央控制和局部控制相结合的方法

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422191917351.png" alt="image-20220422191917351" style="zoom:67%;" />

中央控制就是CU基于时钟给控制信号，局部控制就是自己给时钟信号，<u>不明白这个优点在哪里</u>？



#### 异步控制方式

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422192448142.png" alt="image-20220422192448142" style="zoom:67%;" />

一个微操作完成了，会发应答信号，告诉操作完成，可以进行下一步操作

#### 联合控制方式

同步异步相结合，有的阶段完成时间不太好确定，就用异步方式，比如取指、间址、中断周期比较固定，可以采用同步方式，而如果执行周期采用的是I/O操作,那么时间就不好估计，就可以用异步的应答方式

#### 人工控制方法

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422193004111.png" alt="image-20220422193004111" style="zoom:67%;" />

时序就是控制什么时候执行什么信号，人工控制方式就是遇到这些东西就要执行相应的指令，也就是改变了控制信号（应该？）



### 控制单元的设计

### 组合逻辑控制单元框图

#### CU外特性

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422193431490.png" alt="image-20220422193431490" style="zoom:67%;" />

组合逻辑就是用硬件完成

n位的操作码可以给出2的n次方减1的操作数量， 其中只有1位置1，CU根据操作码译码的结果给出C0-CK的控制信号，可能只有1个控制信号有效，也有可能是多个控制信号有效，如果是多个，那么说明是并行，或者有先后顺序，但是在一个时钟周期内可以按完成次序

#### 节拍信号



<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422193753897.png" alt="image-20220422193753897" style="zoom:67%;" />

每过1个时钟周期就产生一个节拍



#### 微操作的节拍安排

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422194109511.png" alt="image-20220422194109511" style="zoom:67%;" />

所有的控制信号都是基于时钟产生的节拍给出

##### 安排微操作时序的原则

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422194400509.png" alt="image-20220422194400509" style="zoom:67%;" />

原则二的意思就是说两个微操作如果是可以并行的，就尽可能安排在一个节拍中

##### 取指周期微操作节拍的安排

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422194709986.png" alt="image-20220422194709986" style="zoom:67%;" />

T0、T1、T2节拍相继到来，实际上就是一个一个时钟周期到来

在T2，MDR->IR是寄存器到寄存器，相对于T0的内存到寄存器，时间要短得多，所以可以将IR的操作码部分送到CU的ID译码器中，就依据的是原则三两个微操作时间都很短，可以安排在一个节拍中完成

##### 间址周期微操作的节拍安排

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422195125824.png" alt="image-20220422195125824" style="zoom:67%;" />

##### 执行周期微操作的节拍安排

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422195431865.png" alt="image-20220422195431865" style="zoom:67%;" />

CLA：将累加寄存器清零，AC就是ACC

COM：将累加寄存器取反

SHR：逻辑右移，逻辑右移中，右移和写回符号是可以一起做的（数字逻辑实现是这样）

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422195819995.png" alt="image-20220422195819995" style="zoom:67%;" />

CSL：循环左移

STP：停机指令

ADD：加法指令

STA：存数指令，将ACC中的值写入内存单元中

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422200210499.png" alt="image-20220422200210499" style="zoom:67%;" />

LDA：将内存单元的值读到ACC寄存器中

JMP：无条件跳转

BAN：计算结果大于0，继续执行，计算结果小于0，跳转，这里的PC在取指阶段就已经加一指向下一条指令，所以不用加1

A0代表ACC中的数的正负，实际执行过程中需要对标志位进行判断，这里是为了简便表示就用了A0

##### 中断周期的微操作

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422201238386.png" alt="image-20220422201238386" style="zoom:67%;" />

不是真正的指令，只是一系列的硬件操作，称为中断隐指令

### 组合逻辑设计步骤

#### 列出操作时间表

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422201723113.png" alt="image-20220422201723113" style="zoom:67%;" />

太多了，就看看执行阶段就行了

比如在上图中有些指令在某个节拍某个阶段某个微操作命令在某一个指令中需要，比如上面的M（MAR）->MDR在CLA，COM，ADD，STA，LDA，JMP这些指令中都需要，所以这个微指令的发出就需要CU内部有下面这样的一个逻辑图， 这就需要硬件设计，新加入一个指令就要重新设计电路，就比较复杂

#### 写出微操作命令的最简表达式

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422201910667.png" alt="image-20220422201910667" style="zoom:67%;" />



#### 画出逻辑图

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220422201939200.png" alt="image-20220422201939200" style="zoom:67%;" />

数字逻辑部分，不关注了

组合逻辑设计和微程序设计考虑的都是控制器内部的设计，就是怎么根据不同的阶段、不同的时钟周期，不同个命令来执行不同的微操作，比如上面的逻辑电路，从取值、间址、执行整个流程都是设计好的电路，如果没有外部改变，就是机器启动这么一个操作



### 微程序设计

### 微程序设计思想的产生

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220423130502837.png" alt="image-20220423130502837" style="zoom:67%;" />

存储逻辑：逻辑信号存储在存储器中

### 微程序控制单元框图及工作原理

#### 机器指令对应的微程序

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220423130601758.png" alt="image-20220423130601758" style="zoom:67%;" />

#### 微程序控制单元的基本框图

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220423131318377.png" alt="image-20220423131318377" style="zoom:67%;" />

CMDR中的前半部分是操作控制码，每一位即代表一个控制信号，表示要执行的微操作，顺序控制表示的是下一条微指令的地址，输入顺序逻辑进行判断

**关于组合逻辑和微程序，可以想象每一个微操作都有一个小电路部件，比如上面逻辑框图中的内存取数据到MDR中，如果是组合逻辑，一个op来了，比如ADD，要与很多其他的命令一起设计电路图，来达到最后add命令有效时，这个内存取数据到MDR的小电路部件生效，以及其他操作有效，如果有新的指令，这个指令又要考虑和原有指令的关系，重新设计电路图****

**微程序感觉就是只保留各种微操作的小电路，只不过op来了，通过地址译码找到该操作的微程序，微程序里面是一条条微指令，微指令是01代码，就是高低电平，这个高低电平输出去就能直接控制相应的一个小电路部件工作，而不用考虑所有命令来设计电路**，**微程序也有电路设计，但是比较简单，并且有些步骤可以简化成代码的逻辑来理解，而组合逻辑则是考虑到了所有器件，来得出结果**

程序就是简单的硬件配合程序表达的硬件信号实现复杂硬件的功能

#### 微程序控制单元框图及工作原理

![image-20220423132214454](C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220423132214454.png)

M+2结束后下一条指令写单个叉，因为不能由地址直接标识出来，而是由硬件电路来将op译码

间指周期结束还是xxx，由译码器译出指令执行周期微程序所在的地址

#### 工作原理

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220423133331930.png" alt="image-20220423133331930" style="zoom:67%;" />

##### 取指周期

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220423133918955.png" alt="image-20220423133918955" style="zoom:67%;" />

最开始取指阶段的微程序地址M要送给CMAR，注意这里的M不是内存

CM就是控制存储器的简写

取指阶段结束后的下地址是XXX，就说明不能由下地址得到下条指令的地址，要进入间址阶段或者执行阶段，执行阶段就要由译码部分译op操作码给出地址



##### 执行阶段 

 <img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220423134745394.png" alt="image-20220423134745394" style="zoom:67%;" />



##### 又一次取指阶段

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220423135055220.png" alt="image-20220423135055220" style="zoom:67%;" />

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220423135110164.png" alt="image-20220423135110164" style="zoom:67%;" />

微指令的执行顺序就是微指令的执行程序

<u>但是同一条指令里面不并行的两个微操作怎么决定先后顺序？</u>

### 微指令的编码方式（控制方式）

#### 直接编码（直接控制方式）

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220423135420350.png" alt="image-20220423135420350" style="zoom:67%;" />

#### 字段直接编码方式

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220423135602371.png" alt="image-20220423135602371" style="zoom:67%;" />

这里增加了译码步骤，所以增加了译码时间

这里的译码部件比如有n位，那么译码后就是2的n次方，相当于上面直接编码需要2的n次方位，而这里只需要n位

同一字段的命令是互斥的，不同字段的命令是可能相同高的

#### 字段间接编码方式

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220423141143732.png" alt="image-20220423141143732" style="zoom:67%;" />

#### 混合编码

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220423141226088.png" alt="image-20220423141226088" style="zoom:67%;" />

比如比较常见的指令用直接编码

#### 微指令序列地址的形成

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220423141505739.png" alt="image-20220423141505739" style="zoom:67%;" />

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220423141547822.png" alt="image-20220423141547822" style="zoom:67%;" />

通过测试网络也是为了实现小范围的分支转移跳转，一部分测试地址由测试源进行控制，输出改变后的测试地址

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220423142035032.png" alt="image-20220423142035032" style="zoom:67%;" />

PC执行到某一条指令，难么需要去控制存储器执行取指微程序，这个一开始M就是由硬件专门产生

执行周期结束后，如果要进行中断周期，这个控存地址也是由硬件产生

#### 后续微指令地址形成方式原理图

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220423142449102.png" alt="image-20220423142449102" style="zoom:67%;" />

多路选择会选择4个地址中的其中一个



#### 微指令格式

##### 水平型微指令和垂直型微指令

之前所说的都是水平型微指令

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220423142814225.png" alt="image-20220423142814225" style="zoom:67%;" />

##### 两种微指令格式的比较 

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220423143121863.png" alt="image-20220423143121863" style="zoom:67%;" />

#### 静态微程序设计和动态微程序设计

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220423143335320.png" alt="image-20220423143335320" style="zoom:67%;" />

#### 毫微程序设计

##### 毫微程序设计的基本概念

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220423143414100.png" alt="image-20220423143414100" style="zoom:67%;" />

##### 毫微程序控制存储器的基本组成

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220423143609204.png" alt="image-20220423143609204" style="zoom:67%;" />

##### 串行微程序控制和并行微程序控制

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220423143728903.png" alt="image-20220423143728903" style="zoom:67%;" />

本来微程序中的微指令部分就有一部分微操作是并行的了

现在又加了流水，并行的并行

### 微程序设计举例

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220423144435878.png" alt="image-20220423144435878" style="zoom:67%;" />

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220423144713879.png" alt="image-20220423144713879" style="zoom:67%;" />

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220423144816228.png" alt="image-20220423144816228" style="zoom:67%;" />

这里CMAR的地址是M，下一条取指开始

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220423145023286.png" alt="image-20220423145023286" style="zoom:67%;" />

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220423145120113.png" alt="image-20220423145120113" style="zoom:67%;" />

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220423145158292.png" alt="image-20220423145158292" style="zoom:67%;" />

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220423145309401.png" alt="image-20220423145309401" style="zoom:67%;" />

#### 确定微指令格式

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220423145514502.png" alt="image-20220423145514502" style="zoom:67%;" />

因为是直接控制，所以20个微操作是20位，如果是译码，则要5位

微指令就是将一个或几个并行的微操作合在一起作为一条指令

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220423150205534.png" alt="image-20220423150205534" style="zoom:67%;" />

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220423150458544.png" alt="image-20220423150458544" style="zoom:67%;" />

取消了这个指令，应该是用硬件实现了相应功能

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220423150542740.png" alt="image-20220423150542740" style="zoom:67%;" />

<img src="C:\Users\nehc_zy\AppData\Roaming\Typora\typora-user-images\image-20220423151041780.png" alt="image-20220423151041780" style="zoom:67%;" />

